{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./miner.js","webpack:///./test3.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,aAAa,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,sBAAsB,sBAAsB;AAC5C;AACA;AACA,sBAAsB,yCAAyC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB,EAAE;AACvE,kDAAkD,mBAAmB,EAAE;AACvE,kDAAkD,mBAAmB,EAAE;AACvE,kDAAkD,mBAAmB,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc,EAAE;AACpE,mDAAmD,cAAc,EAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ,aAAa,mBAAO,CAAC,8BAAY;AACjC;AACA;AACA,CAAC;;;;;;;;;;;;ACzLD;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,sFAAsF;AAC3F,KAAK,iGAAiG;AACtG,KAAK,mDAAmD;AACxD,KAAK,iGAAiG;AACtG,KAAK,6FAA6F;AAClG,KAAK,sDAAsD;AAC3D,KAAK,sDAAsD;AAC3D,KAAK,sDAAsD;AAC3D,KAAK,6FAA6F;AAClG,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAoD;AAC1E,SAAS;AACT,sBAAsB,yFAAyF;AAC/G;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,qGAAqG;AACvH;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE,GAAG;AACpC;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK,EAAE;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;;AAExC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA,+BAA+B;;;AAG/B;AACA,6CAA6C,qBAAqB;AAClE;AACA;AACA;AACA,uBAAuB,MAAM,GAAG,WAAW,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK,EAAE;AAC/B;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,YAAY,EAAE;AAC/C,wCAAwC,qBAAqB,IAAI,GAAG,IAAI,GAAG,EAAE;;AAE7E,mCAAmC,mBAAmB,EAAE;AACxD,mCAAmC,mBAAmB,EAAE;AACxD,mCAAmC,mBAAmB,EAAE;AACxD,mCAAmC,mBAAmB,EAAE;;;AAGxD;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA,+BAA+B,GAAG,GAAG,GAAG;AACxC;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,YAAY;AACZ;;AAEA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;;AAGA,YAAY;AACZ;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;;AAEN;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;;AAEA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./miner.js\");\n","// // const Vertex = require(\"./vertex.js\");\n// const Vertex = require(\"./vertex.js\");\n//\n// // import Vertex from \"./vertex.js\";\n//\n// document.addEventListener(\"DOMContentLoaded\", () => {\n//   const canvas = document.getElementById(\"canvas\");\n//   const ctx = canvas.getContext(\"2d\");\n//\n//   // const Vertex = function(x,y,r){\n//   //   this.x = x,\n//   //   this.y = y,\n//   //   this.r = r\n//   // }\n//   //\n//   // Vertex.prototype.render = function(ctx){\n//   //   ctx.beginPath();\n//   //   ctx.arc(this.x,this.y,this.r,0,2*Math.PI);\n//   //   ctx.fillStyle = \"red\";\n//   //   ctx.fill();\n//   // }\n//\n//   const Edge = function(v1, v2){\n//     this.v1 = v1;\n//     this.v2 = v2;\n//   }\n//\n//   Edge.prototype.render = function(ctx){\n//     ctx.beginPath();\n//     ctx.moveTo(this.v1.x,this.v1.y);\n//     ctx.lineTo(this.v2.x,this.v2.y);\n//     ctx.lineWidth = 10;\n//     ctx.strokeStyle = \"purple\";\n//     ctx.stroke();\n//   }\n//\n//   const EdgeArrow = function(v1,v2){\n//\n//   }\n//\n//   const matrix = [\n//     [0,0,1,1,1,0],\n//     [0,0,0,1,1,1],\n//     [0,0,0,0,0,0],\n//     [0,0,0,0,0,0],\n//     [0,0,0,0,0,0],\n//     [0,0,0,0,0,0]\n//   ]\n//\n//   const vertices = [\n//     new Vertex(300,300,20),\n//     new Vertex(500,300,20),\n//\n//     new Vertex(100,100,20),\n//     new Vertex(300,100,20),\n//     new Vertex(500,100,20),\n//     new Vertex(700,100,20)\n//   ]\n//   const edges = [];\n//\n//   const generateEdgesFromMatrix = function(matrix){\n//     matrix.forEach((row, i) => {\n//       row.forEach((el, j) => {\n//         if (el > 0){\n//           edges.push(new Edge(vertices[i],vertices[j]));\n//         }\n//       })\n//     })\n//   }\n//\n//   generateEdgesFromMatrix(matrix);\n//\n//\n//   // const edges = [\n//   //   new Edge(vertices[4],vertices[0]),\n//   //   new Edge(vertices[4],vertices[1]),\n//   //   new Edge(vertices[4],vertices[2]),\n//   //   new Edge(vertices[5],vertices[1]),\n//   //   new Edge(vertices[5],vertices[2]),\n//   //   new Edge(vertices[5],vertices[3])\n//   // ]\n//\n//   edges.forEach((edge) => {\n//     edge.render(ctx);\n//   })\n//\n//   vertices.forEach((vertex) => {\n//     vertex.render(ctx);\n//   })\n//\n//   // v1.render(ctx);\n//   // v2.render(ctx);\n//   // v3.render(ctx);\n//   // v4.render(ctx);\n//   // v5.render(ctx);\n//   // v6.render(ctx);\n//\n// });\n\n// document.addEventListener(\"DOMContentLoaded\", () => {\n//\n//   var svg = d3.select(\"svg\"),\n//       width = +svg.attr(\"width\"),\n//       height = +svg.attr(\"height\");\n//\n//\n//               var simulation = d3.forceSimulation()\n//                   .force(\"link\", d3.forceLink().id(function(d) { return d.id; }))\n//                   //.force(\"charge\", d3.forceManyBody().strength(-200))\n//               \t\t.force('charge', d3.forceManyBody()\n//                     .strength(-1000)\n//                   )\n//               // \t\t.force('collide', d3.forceCollide()\n//               //       .radius(d => 40)\n//               //       .iterations(2)\n//               //     )\n//                   .force(\"center\", d3.forceCenter(width / 2, height / 2));\n//               const graph = {\n//                 \"nodes\": [\n//                   {\"id\": \"1\", \"group\": 1},\n//                   {\"id\": \"2\", \"group\": 2},\n//                 ],\n//                 \"links\": [\n//                   {\"source\": \"1\", \"target\": \"2\", \"value\": 1},\n//                 ]\n//               }\n//\n//\n//               function run(graph) {\n//\n//                 graph.links.forEach(function(d){\n//               //     d.source = d.source_id;\n//               //     d.target = d.target_id;\n//                 });\n//                 var link = svg.append(\"g\")\n//                               .style(\"stroke\", \"#aaa\")\n//                               .selectAll(\"line\")\n//                               .data(graph.links)\n//                               .enter().append(\"line\");\n//                 var node = svg.append(\"g\")\n//                           .attr(\"class\", \"nodes\")\n//                 .selectAll(\"circle\")\n//                           .data(graph.nodes)\n//                 .enter().append(\"circle\")\n//                         .attr(\"r\", 2)\n//\n//\n//                 var label = svg.append(\"g\")\n//                     .attr(\"class\", \"labels\")\n//                     .selectAll(\"text\")\n//                     .data(graph.nodes)\n//                     .enter().append(\"text\")\n//                       .attr(\"class\", \"label\")\n//                       .text(function(d) { return d.id; });\n//                 simulation\n//                     .nodes(graph.nodes)\n//                     .on(\"tick\", ticked);\n//                 simulation.force(\"link\")\n//                     .links(graph.links);\n//                 function ticked() {\n//                   link\n//                       .attr(\"x1\", function(d) { return d.source.x; })\n//                       .attr(\"y1\", function(d) { return d.source.y; })\n//                       .attr(\"x2\", function(d) { return d.target.x; })\n//                       .attr(\"y2\", function(d) { return d.target.y; });\n//                   node\n//                        .attr(\"r\", 16)\n//                        .style(\"fill\", \"#efefef\")\n//                        .style(\"stroke\", \"#424242\")\n//                        .style(\"stroke-width\", \"1px\")\n//                        .attr(\"cx\", function (d) { return d.x+5; })\n//                        .attr(\"cy\", function(d) { return d.y-3; });\n//                 }\n//               }\n//\n//\n//               run(graph)\n//\n//\n// });\n\n\nconst draw = require(\"./test3.js\");\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  draw();\n});\n","// const EK = require(\"./ek-animated.js\");\n\n\nconst draw3 = function(){\n  let width = 900,\n      height = 900;\n\n  animationInterval = 100;\n\n  let matrix = [\n    [0,4,1,1,0,0,0,0,0,0],\n    [0,0,0,0,25,25,25,0,0,0],\n    [0,0,0,0,0,25,25,25,0,0],\n    [0,0,0,0,0,0,25,25,25,0],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,0]\n  ]\n\n  let nodes = [\n    {label: \"s\", index: 0, profit: null, row: null, fixed: true, x: width/2, y: height-100},\n    {label: \"a\", index: 1, profit: matrix[0][1], row: 1, fixed: true, x: width/2-150, y: height - 325},\n    {label: \"b\", index: 2, profit: matrix[0][2], row: 1},\n    {label: \"c\", index: 3, profit: matrix[0][3], row: 1, fixed: true, x: width/2+150, y: height - 325},\n    {label: \"d\", index: 4, profit: matrix[4][9]*-1, row: 0, fixed: true, x: width/2 - 200, y: 325},\n    {label: \"e\", index: 5, profit: matrix[5][9]*-1, row: 0},\n    {label: \"f\", index: 6, profit: matrix[6][9]*-1, row: 0},\n    {label: \"g\", index: 7, profit: matrix[7][9]*-1, row: 0},\n    {label: \"h\", index: 8, profit: matrix[8][9]*-1, row: 0, fixed: true, x: width/2 + 200, y: 325},\n    {label: \"t\", index: 9, profit: null, row: null, fixed: true, x: width/2, y: 100}\n  ]\n\n  let links = [\n  ]\n\n  //defines the u -> v edges, i.e. must complete project v before starting project u\n  let restrictions = [\n    {source: 1, target: 4},\n    {source: 1, target: 5},\n    {source: 1, target: 6},\n    {source: 2, target: 5},\n    {source: 2, target: 6},\n    {source: 2, target: 7},\n    {source: 3, target: 6},\n    {source: 3, target: 7},\n    {source: 3, target: 8},\n  ]\n\n  //effectively the sum of all other capacities + 1 (commonly C + 1)\n  infCapacity = 0;\n\n  //computes C + 1\n  const simulateInfCapacity = () => {\n    nodes.forEach(node => {\n      if (node.profit !== null){\n        if (node.profit > 0){\n          infCapacity = infCapacity + node.profit\n        }else{\n          infCapacity = infCapacity - node.profit\n        }\n      }\n    })\n    infCapacity = infCapacity + 1;\n  }\n\n  let linkIdIdx = 0;\n  //creates links with finite capacities\n  const setFiniteLinks = () => {\n    nodes.forEach((node,i) => {\n      // debugger\n      if (node.label !== \"s\" && node.label !== \"t\"){\n        if (node.profit > 0){\n          links.push({source: 0, target: i, res: 0, capacity: node.profit})\n        }else{\n          links.push({source: i, target: (nodes.length-1), capacity: (-1 * node.profit), res: 0, id: linkIdIdx})\n        }\n      }\n      linkIdIdx = linkIdIdx + 1;\n    })\n  }\n  //creates links with infinite capacities\n  const setInfiniteLinks = () => {\n    restrictions.forEach(restriction => {\n      links.push({source: restriction.source, target: restriction.target, res: 0, capacity: infCapacity, id: linkIdIdx})\n      linkIdIdx = linkIdIdx + 1;\n    })\n  }\n  simulateInfCapacity();\n  setInfiniteLinks();\n  setFiniteLinks();\n  // debugger\n\n  //create object for manipulation\n  let svg = d3.select('body').append('svg')\n      .attr('width', width)\n      .attr('height', height);\n\n\n  // debugger\n  //apply force conditions\n  let force = d3.layout.force()\n      .size([width, height])\n      .nodes(d3.values(nodes))\n      .links(links)\n      .on(\"tick\", tick)\n      // .linkDistance(100)\n      .gravity(0.1)\n      .charge(-1200)\n      .linkDistance(120)\n      .linkStrength(0.1)\n      .start();\n\n      // link.append(\"linkLabel\")\n      //   .append(\"text\")\n      //   .attr(\"class\",\"linkLabel\")\n      //   .attr(\"x\",\"50\")\n      //   .attr(\"y\",\"-20\")\n      //   .attr(\"text-anchor\",\"start\")\n      //   .style(\"fill\",\"#000\")\n      //   .attr(\"xlink:href\",function(d,i){\n      //     debugger\n      //     return `#linkId_${i}`;})\n      //   .text(function(d) {\n      //     return d.id;\n      //   })\n\n  //create links\n  let link = svg.append(\"g\").selectAll('.link')\n      .data(force.links())\n      .enter().append('line')\n      .attr(\"class\", \"link\")\n      .attr('id', function(d) {\n        return `link_${d.id}`})\n      .style(\"stroke\", function(d){\n        if (d.capacity === infCapacity){\n          return \"#000\"\n        }else if (d.target.label === \"t\"){\n          return \"#632f12\"\n        }else if ( d.source.label === \"s\"){\n          return \"#fff\"\n        }\n      })\n      // .attr(\"marker-end\",\"url(#arrowhead)\")\n      .style(\"stroke-width\", \"4\")\n\n      //create nodes\n      let node = svg.selectAll(\".node\")\n      .data(force.nodes())\n      .enter().append(\"g\")\n      .attr('class', 'node')\n      // .attr(\"transform\",transform);\n      .call(force.drag);\n\n      //add circle to visualize nodes\n      node.append(\"circle\")\n      .attr('r', 12)\n      .attr(\"fill\", function(d) {\n        if (d.label === \"s\"){\n          return \"#ce9308\"\n        }else if (d.label === \"t\"){\n          return \"#969696\"\n        }else if (d.profit !== null && d.profit > 0){\n          return \"#31703d\"\n        }else if (d.profit !== null && d.profit <= 0){\n          return \"#961919\"\n        }\n      })\n      .style(\"stroke\", \"#fff\")\n      .style(\"stroke-weight\", \"3\")\n\n      //add node labels\n      node.append(\"text\")\n      .attr(\"dx\", \"-.2em\")\n      .attr(\"dy\", \".35em\")\n      .style(\"fill\", \"white\")\n      .text(function(d) {return d.label})\n\n  let edgepaths = svg.selectAll(\".edgepath\")\n      .data(links)\n      .enter()\n      .append('path')\n      .attr({'d': function(d) {\n        // debugger\n        return 'M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y},\n             'class':'edgepath',\n             'fill-opacity':0,\n             'stroke-opacity':0,\n             'fill':'blue',\n             'stroke':'red',\n             'id':function(d,i) {return 'edgepath'+i}})\n      .style(\"pointer-events\", \"none\");\n\n      var edgelabels = svg.selectAll(\".edgelabel\")\n          .data(links)\n          .enter()\n          .append('text')\n          .style(\"pointer-events\", \"none\")\n          .attr({'class':'edgelabel',\n                 'id':function(d,i){return 'edgelabel'+i},\n                 'dx':80,\n                 'dy':-5,\n                 'font-size':20,\n                 'fill':'#aaa'});\n\n\n       edgelabels.append('textPath')\n           .attr('xlink:href',function(d,i) {return '#edgepath'+i})\n           .style(\"pointer-events\", \"none\")\n           .text(function(d){\n             // debugger\n             return `${d.res}:${d.capacity}`});\n    //\n    // let link = svg.selectAll(\".link\")\n    //   .data(force.links())\n    //   .enter().append(\"g\")\n    //   .attr(\"class\",\"link\")\n    //\n    //\n    // link.append(\"line\")\n    // .attr('id', function(d) {\n    //   return `link_${d.id}`})\n    // .style(\"stroke\", function(d){\n    //   if (d.capacity === infCapacity){\n    //     return \"#000\"\n    //   }else if (d.target.label === \"t\"){\n    //     return \"#632f12\"\n    //   }else if ( d.source.label === \"s\"){\n    //     return \"#fff\"\n    //   }\n    // })\n    // .style(\"stroke-width\", \"5\");\n\n  function tick(e) {\n      node.attr('cx', function(d) {\n          return d.x;\n        })\n        .attr('cy', function(d) { return d.y; })\n        .attr(\"transform\", function(d) { return `translate(${d.x},${d.y})`; });\n\n      link.attr('x1', function(d) { return d.source.x; })\n          .attr('y1', function(d) { return d.source.y; })\n          .attr('x2', function(d) { return d.target.x; })\n          .attr('y2', function(d) { return d.target.y; });\n\n\n      edgepaths.attr('d', function(d) {\n        let path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;\n        return path\n      });\n\n      // edgelabels.attr('transform',function(d,i){\n      //     if (d.target.x<d.source.x){\n      //         bbox = this.getBBox();\n      //         rx = bbox.x+bbox.width/2;\n      //         ry = bbox.y+bbox.height/2;\n      //         return 'rotate(180 '+rx+' '+ry+')';\n      //         }\n      //     else {\n      //         return 'rotate(0)';\n      //         }\n      // });\n\n      edgelabels.attr(\"transform\", function(d,i){\n        if (d.target.x < d.source.x){\n          bbox = this.getBBox();\n          rx = bbox.x + bbox.width/2;\n          ry = bbox.y + bbox.height/2;\n          return `rotate(180 ${rx} ${ry})`;\n        }\n        else{\n          return \"rotate(0)\";\n        }\n      })\n  }\n\n  const BFS = (graph, s, t, parent) => {\n    let visited = [];\n    for (let i = 0; i < 5; i++){\n      visited.push(false);\n    }\n\n    let queue = [];\n\n    queue.push(s);\n    visited[s] = true;\n    // debugger\n    while (queue.length > 0) {\n      let currentVtx = queue.shift();\n\n      graph[currentVtx].forEach((val, i) => {\n        if (!visited[i] && val > 0){\n          queue.push(i);\n          visited[i] = true;\n          parent[i] = currentVtx;\n        }\n      })\n    }\n    return {pathToSink: visited[t], parent}\n  }\n\n  let parent = [];\n\n  for (let i = 0; i < matrix.length; i++){\n    parent.push(-1);\n  }\n\n  let count = 30;\n  const EK = (graph, source, sink) => {\n\n\n    let max_flow = 0;\n    // debugger\n    while (BFS(graph, source, sink, parent).pathToSink) {\n      let path_flow = 91;\n      let s = sink;\n      let path = [s];\n      while (s != source){\n        path_flow = Math.min(path_flow, graph[parent[s]][s]);\n        s = parent[s];\n        path.unshift(s);\n      }\n      // debugger\n      animatePath(path, count, \"search\");\n      max_flow = max_flow + path_flow;\n      // debugger\n      count = count + (path.length - 1);\n\n      let t = sink;\n      let augmentingPath = [t];\n      while (t != source){\n        let u = parent[t];\n        graph[u][t] =  graph[u][t] - path_flow;\n        graph[t][u] = graph[t][u] + path_flow;\n        t = parent[t];\n        augmentingPath.push(t)\n      }\n      animatePath(augmentingPath, count, \"augment\")\n\n      count = count + (path.length - 1);\n      // debugger\n\n      resetBFSLinks(path, count);\n      count = count + 1;\n    }\n\n    let solution = [];\n    let queue = []\n\n    //finds solution nodes\n    graph[0].forEach((el,i) => {\n      if (el > 0){\n        solution.push(i);\n        queue.push(i);\n      }\n    })\n    while (queue.length > 0){\n      let nextNode = queue.shift();\n      graph[nextNode].forEach((el,i) => {\n        if (el > 0 && !solution.includes(i)){\n          solution.push(i);\n          queue.push(i);\n        }\n      })\n    }\n    count = count + 1;\n\n\n    return {max_flow, solution};\n  }\n\n\n  // setTimeout(function(){\n    // svg.selectAll(\".node\").filter(function(d){\n    //   debugger\n    //   return;\n    // })\n  //   , 1000);\n  // })\n\n  // let result = EK(matrix,0,9);\n  // highlightSolution(result.solution, count);\n  // debugger\n\n\n  function highlightSolution(solution, count){\n    setTimeout(function(){\n      svg.selectAll(\"circle\").filter(function(d) {\n        // debugger\n        return solution.includes(d.index);\n      })\n      .transition()\n      .duration(1000)\n      .attr(\"fill\", \"white\")\n\n      svg.selectAll(\"text\").filter(function(d) {\n        // debugger\n        return solution.includes(d.index);\n      })\n      .transition()\n      .duration(1000)\n      .style(\"fill\", \"black\")\n    },animationInterval*count)\n  }\n\n  function animatePath(path, count, type) {\n    for (let i = 0; i < path.length - 1; i++){\n      setTimeout(function(){\n        svg.selectAll(\".link\")\n        .filter(function(d){\n          if (type === \"search\"){\n            return d.source.index === path[i] && d.target.index === path[i+1]\n          }else{\n            return d.source.index === path[i+1] && d.target.index === path[i]\n          }\n        })\n        .transition()\n        .duration(animationInterval)\n        .style(\"stroke\", function(){\n          if (type === \"search\"){\n            return \"red\"\n          }else if (type === \"augment\"){\n            return \"#039ab5\"\n          }\n        })\n      }, animationInterval*count)\n      count = count + 1\n      // debugger\n    }\n\n  }\n\n  function resetBFSLinks(path,count){\n    for (let i = 0; i < path.length - 1; i++){\n      setTimeout(function(){\n        svg.selectAll(\".link\")\n        .filter(function(d){\n          // debugger\n          return d.source.index === path[i] && d.target.index === path[i+1]\n        })\n        .transition()\n        .duration(animationInterval)\n        .style(\"stroke\", function(d){\n          if (d.capacity === infCapacity){\n            return \"#000\"\n          }else if (d.target.label === \"t\"){\n            return \"#632f12\"\n          }else if ( d.source.label === \"s\"){\n            return \"#fff\"\n          }\n        })\n      }, animationInterval*count)\n    }\n  }\n\n}\n\nmodule.exports = draw3;\n"],"sourceRoot":""}