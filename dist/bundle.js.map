{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./graph.js","webpack:///./graph2.js","webpack:///./mineTest.js","webpack:///./miner.js","webpack:///./solver.js","webpack:///./test3.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;AAAA;AAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,YAAY;AACjC;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gMAAgM;AAChO,WAAW;AACX,gCAAgC,kMAAkM;AAClO,WAAW;AACX,gCAAgC,gGAAgG;AAChI;AACA;AACA,OAAO;AACP,KAAK;AACL,wBAAwB,0FAA0F;AAClH,qBAAqB,sFAAsF;AAC3G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAuD;AAClF;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,+BAA+B,YAAY,EAAE;AAC7C,sCAAsC,qBAAqB,IAAI,GAAG,IAAI,GAAG,EAAE;;AAE3E;AACA;AACA;AACA,0BAA0B,EAAE;AAC5B,+BAA+B,mBAAmB,EAAE;AACpD,+BAA+B,mBAAmB,EAAE;AACpD,+BAA+B,mBAAmB,EAAE;;;AAGpD;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,+BAA+B,GAAG,GAAG,GAAG;AACxC;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAK,EAAE;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;;AAExC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB,eAAe,GAAG,eAAe,GAAG;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,yBAAyB,qBAAqB;AAC9C;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe,GAAG,eAAe,EAAE;AAC/D,gCAAgC;AAChC;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA,oBAAoB,MAAM,GAAG,IAAI,EAAE;;;AAGnC;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,kDAAM;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;ACnUrB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,sGAAsG;AAC3H,OAAO,sHAAsH;AAC7H,OAAO,wDAAwD;AAC/D,OAAO,sHAAsH;AAC7H,OAAO,0GAA0G;AACjH,OAAO,2DAA2D;AAClE,OAAO,2DAA2D;AAClE,OAAO,2DAA2D;AAClE,OAAO,0GAA0G;AACjH,OAAO;AACP;;AAEA;AACA,OAAO,qBAAqB;AAC5B,OAAO,qBAAqB;AAC5B,OAAO,qBAAqB;AAC5B,OAAO,qBAAqB;AAC5B,OAAO,qBAAqB;AAC5B,OAAO,qBAAqB;AAC5B,OAAO,qBAAqB;AAC5B,OAAO,qBAAqB;AAC5B,OAAO,qBAAqB;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sFAAsF;AAChG,UAAU,iGAAiG;AAC3G,UAAU,mDAAmD;AAC7D,UAAU,iGAAiG;AAC3G,UAAU,6FAA6F;AACvG,UAAU,sDAAsD;AAChE,UAAU,sDAAsD;AAChE,UAAU,sDAAsD;AAChE,UAAU,6FAA6F;AACvG,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qBAAqB;AAC/B,UAAU,qBAAqB;AAC/B,UAAU,qBAAqB;AAC/B,UAAU,qBAAqB;AAC/B,UAAU,qBAAqB;AAC/B,UAAU,qBAAqB;AAC/B,UAAU,qBAAqB;AAC/B,UAAU,qBAAqB;AAC/B,UAAU,qBAAqB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAoD;AAC/E,cAAc;AACd,2BAA2B,yFAAyF;AACpH;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,uBAAuB,qGAAqG;AAC5H;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,qCAAqC,YAAY,EAAE;AACnD,4CAA4C,qBAAqB,IAAI,GAAG,IAAI,GAAG,EAAE;;AAEjF;AACA,wCAAwC,mBAAmB,EAAE;AAC7D,mCAAmC,mBAAmB,EAAE;AACxD,mCAAmC,mBAAmB,EAAE;AACxD,mCAAmC,mBAAmB,EAAE;;;AAGxD;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG,GAAG,GAAG;AAC5C;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,EAAE,GAAG;AACtC;AACA;AACA,cAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK,EAAE;AAChC;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;;AAE1C;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB,eAAe,GAAG,eAAe,GAAG;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,oCAAoC,eAAe,GAAG,eAAe,EAAE;AACvE,uCAAuC;AACvC;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA,yBAAyB,MAAM,GAAG,IAAI,EAAE;;AAExC;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,oCAAoC,YAAY,EAAE;AAClD,2CAA2C,qBAAqB,IAAI,GAAG,IAAI,GAAG,EAAE;AAChF;AACA,2CAA2C,mBAAmB,EAAE;AAChE,sCAAsC,mBAAmB,EAAE;AAC3D,sCAAsC,mBAAmB,EAAE;AAC3D,sCAAsC,mBAAmB,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,GAAG,GAAG,GAAG;AAC3C;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;AC7WrB;AAAA;AAA+B;;AAE/B;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B,YAAY,mBAAmB;AAC/B,YAAY,mBAAmB;AAC/B,YAAY,mBAAmB;AAC/B,YAAY;AACZ;AACA;AACA,YAAY,wBAAwB;AACpC,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;AAC9B,YAAY;AACZ;AACA;AACA,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY;AACZ;;;AAGA;AACA,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,YAAY,oBAAoB;AAChC,eAAe;AACf;AACA;AACA,SAAS,mBAAmB;AAC5B,SAAS,mBAAmB;AAC5B,SAAS,mBAAmB;AAC5B,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B,YAAY;AACZ;AACA;AACA,SAAS,mBAAmB;AAC5B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,YAAY;AACZ;AACA;AACA,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,sEAAsE;AAC7E,OAAO,wEAAwE;AAC/E,OAAO,wEAAwE;AAC/E,OAAO,uEAAuE;AAC9E,UAAU;AACV;AACA;AACA;AACA;AACA,qBAAqB,iDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA,0BAA0B,0EAA0E;AACpG,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,IAAI,IAAI,GAAG;AACrC,KAAK;AACL;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,qBAAqB,MAAM,GAAG,MAAM;AACpC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,uDAAuD,IAAI,gBAAgB;AACrG,KAAK;AACL;AACA,2BAA2B,MAAM,GAAG,MAAM;AAC1C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0EAA0E;AAC1E;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,yBAAyB,KAAK,EAAE;AAC3D,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA,qBAAqB,UAAU;AAC/B,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,aAAa,IAAI,GAAG;AAC9C,KAAK;AACL;AACA,8BAA8B,KAAK;AACnC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB,SAAS;AAC7B,OAAO;AACP,oBAAoB,cAAc;AAClC;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,aAAa,IAAI,EAAE;AAC7C,KAAK;AACL;AACA,8BAA8B,KAAK;AACnC,KAAK;AACL;AACA;AACA,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,GAAG,IAAI,GAAG;AACpC,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B,IAAI,IAAI,GAAG;AACxC,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,IAAI,IAAI,GAAG;AACxC,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,UAAU,aAAa;AACvB,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,mCAAmC,YAAY,EAAE;AACjD,mCAAmC,YAAY,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,sFAAsF;AACtF;AACA;AACA;AACA;AACA;AACA,kCAAkC,yBAAyB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC,wCAAwC;AACxC;AACA;;AAEA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,mBAAmB;AAC5B,SAAS,mBAAmB;AAC5B,SAAS,mBAAmB;AAC5B,SAAS,oBAAoB;AAC7B,SAAS,oBAAoB;AAC7B,YAAY;AACZ;AACA;AACA,SAAS,mBAAmB;AAC5B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,YAAY;AACZ;AACA;AACA,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,SAAS,kBAAkB;AAC3B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,IAAI,GAAG,IAAI;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,UAAU,GAAG,UAAU;;;AAG9E;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,MAAM,GAAG,MAAM;AAC5D,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6CAA6C,MAAM,GAAG,MAAM;AAC5D,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM,GAAG,MAAM;AACzD;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA,iGAAiG,mBAAmB;AACpH,WAAW;AACX;AACA;AACA;AACA,sDAAsD,MAAM,GAAG,MAAM;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb,iCAAiC,8BAA8B;AAC/D;AACA;;AAEA;AACA;AACA,0BAA0B,kEAAkE;AAC5F;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;AACA,uEAAuE,YAAY;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;;AAEe,mEAAI,EAAC;;;;;;;;;;;;;AC1xBpB;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,aAAa,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,sBAAsB,sBAAsB;AAC5C;AACA;AACA,sBAAsB,yCAAyC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB,EAAE;AACvE,kDAAkD,mBAAmB,EAAE;AACvE,kDAAkD,mBAAmB,EAAE;AACvE,kDAAkD,mBAAmB,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc,EAAE;AACpE,mDAAmD,cAAc,EAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ,aAAa,mBAAO,CAAC,8BAAY;AACA;AACF;AACE;AACjC;AACA;AACA;AACA;AACA,iBAAiB,oDAAI;AACrB;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AClMD;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C,KAAK;;AAEL;AACA;;;AAGA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;;AAGA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA,kBAAkB,mCAAmC,GAAG,IAAI;AAC5D,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,mBAAmB,MAAM,GAAG,OAAO;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEe,qEAAM,EAAC;;;;;;;;;;;;ACzkBtB;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK,sFAAsF;AAC3F,KAAK,iGAAiG;AACtG,KAAK,mDAAmD;AACxD,KAAK,iGAAiG;AACtG,KAAK,6FAA6F;AAClG,KAAK,sDAAsD;AAC3D,KAAK,sDAAsD;AAC3D,KAAK,sDAAsD;AAC3D,KAAK,6FAA6F;AAClG,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAoD;AAC1E,SAAS;AACT,sBAAsB,yFAAyF;AAC/G;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,qGAAqG;AACvH;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,mCAAmC,YAAY,EAAE;AACjD,0CAA0C,qBAAqB,IAAI,GAAG,IAAI,GAAG,EAAE;;AAE/E;AACA,iCAAiC,mBAAmB,EAAE;AACtD,iCAAiC,mBAAmB,EAAE;AACtD,iCAAiC,mBAAmB,EAAE;AACtD,iCAAiC,mBAAmB,EAAE;;;AAGtD;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA,iCAAiC,GAAG,GAAG,GAAG;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,EAAE,GAAG;AACpC;AACA;AACA,YAAY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK,EAAE;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;;AAExC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB,eAAe,GAAG,eAAe,GAAG;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe,GAAG,eAAe,EAAE;AACrE,qCAAqC;AACrC;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,uBAAuB,MAAM,GAAG,IAAI,EAAE;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK,EAAE;AAC/B;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ,oCAAoC,YAAY,EAAE;AAClD,2CAA2C,qBAAqB,IAAI,GAAG,IAAI,GAAG,EAAE;AAChF;AACA,sCAAsC,mBAAmB,EAAE;AAC3D,sCAAsC,mBAAmB,EAAE;AAC3D,sCAAsC,mBAAmB,EAAE;AAC3D,sCAAsC,mBAAmB,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,GAAG,GAAG,GAAG;AAC3C;AACA;AACA;AACA;AACA,UAAU;AACV;;;AAGA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,YAAY;AACZ;;AAEA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;;AAGA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN;;;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA,kBAAkB,mCAAmC,GAAG,IAAI;AAC5D;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;;AAEA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./miner.js\");\n","import Solver from \"./solver.js\";\n\nclass Graph {\n  constructor(mineSvg){\n    this.mineSvg = mineSvg;\n    this.matrix = [];\n    this.mine;\n    this.mineH;\n    this.mineW;\n    this.infCapacity = 1000000;\n    this.svgWidth = 820;\n    this.svgHeight = window.innerHeight-250;\n    this.svgGraph = d3.select(\".svgGraphBody\").append(\"svg\").attr(\"class\",\"svgGraph\").attr(\"width\", this.svgWidth).attr(\"height\", this.svgHeight);\n    this.nodes = [];\n    this.links = [];\n    this.node;\n    this.edgepaths;\n    this.edgelabels;\n    this.link;\n    this.nodeLabelList = \"abcdefghijklmnopqruvwxyz\"\n    this.innerNodeCount;\n    this.force;\n    this.animationInterval = 1000;\n    this.parent = [];\n\n    this.count = 0;\n    this.max_flow = 0;\n    this.cont = true;\n    this.playback = false;\n    this.stepping = false;\n    // debugger\n    this.solver;// = new Solver();\n  }\n\n  clearGraph(){\n    d3.select(\".svgGraph\").selectAll(\"*\").remove();\n    this.nodes = [];\n    this.links = [];\n    this.matrix = [];\n  }\n\n  populateMatrix(size){\n    for (let row = 0; row < size; row++){\n      let newRow = []\n      for (let col = 0; col < size; col++){\n        newRow.push(0)\n      }\n      this.matrix.push(newRow);\n    }\n    for (let i = 0; i < this.matrix.length; i++){\n      this.parent.push(-1);\n    }\n\n  }\n\n  findBlocksAbove(i,j,mine){\n    if (i === 0) return [];\n    return [[i-1,j],[i-1,j+1]]\n  }\n\n  findNodeNum(i,j,mine){\n    return 1 + mine[i][j].idx;\n  }\n\n  generateMatrixFromMine(mineObj){\n    this.mine = mineObj.mine;\n    debugger\n    const matrixSize = mineObj.numBlocks + 2;\n    this.populateMatrix(matrixSize);\n    // this.innerNodeCount = 0;\n    let nodeLayers = mineObj.nodeLayers;\n    // this.mineH = mine.length;\n    // this.mineW = mine[0].length;\n    this.mine.forEach((row,i) => {\n      let tmpRow = row.slice();\n      tmpRow.forEach((el, j) => {\n        // debugger\n        if (el.profit !== null){\n          // this.innerNodeCount++;\n          let newPos = this.findNodeNum(i,j,this.mine);\n          if (el.profit > 0) this.matrix[0][newPos] = el.profit;\n          else if (el.profit < 0) this.matrix[newPos][this.matrix.length - 1] = (-1*el.profit);\n          let aboves = this.findBlocksAbove(i,j,this.mine);\n          // debugger\n          aboves.forEach(pos => {\n            el;\n            mineObj;\n            // debugger\n            let intRow = this.findNodeNum(i,j,this.mine);\n            let intCol = this.findNodeNum(pos[0],pos[1],this.mine);\n            this.matrix[intRow][intCol] = this.infCapacity;\n          })\n        }\n      })\n    })\n    this.populateNodes(mineObj);\n  }\n\n  populateNodes(mineObj){\n    const matrixSize = mineObj.numBlocks + 2;\n    this.innerNodeCount = matrixSize-1;\n    let nodeLayers = mineObj.nodeLayers;\n    this.mine.forEach((row,i) => {\n      let tmpRow = row.slice();\n      tmpRow.reverse().forEach((el,j) => {\n        if (el.profit !== null){\n          this.innerNodeCount--;\n          if (nodeLayers[i][0] === el.idx){\n            this.nodes.unshift({label: this.nodeLabelList[this.innerNodeCount-1], index: this.innerNodeCount, profit: el.profit, fixed: true, x: this.svgWidth/8, y: 100 + ((this.svgHeight-200)/(nodeLayers.length + 1)*(i+1))});\n          }else if (nodeLayers[i][1] === el.idx){\n            this.nodes.unshift({label: this.nodeLabelList[this.innerNodeCount-1], index: this.innerNodeCount, profit: el.profit, fixed: true, x: 7*this.svgWidth/8, y: 100 + ((this.svgHeight-200)/(nodeLayers.length + 1)*(i+1))});\n          }else{\n            this.nodes.unshift({label: this.nodeLabelList[this.innerNodeCount-1], index: this.innerNodeCount, profit: el.profit});\n          }\n        }\n      })\n    })\n    this.nodes.unshift({label: \"s\", index: 0, profit: null, fixed: true, x: this.svgWidth/2, y: this.svgHeight-25});\n    this.nodes.push({label: \"t\", index: matrixSize-1, profit: null, fixed: true, x: this.svgWidth/2, y: 50});\n    debugger;\n  }\n\n  populateLinks(){\n    let linkId = 0;\n    // debugger\n    this.matrix.forEach((row,i) => {\n      row.forEach((el,j) => {\n        if (el > 0){\n          // debugger\n          this.links.push({source: i, target: j, res: 0, capacity: el, id: linkId});\n          linkId = linkId + 1;\n        }\n      })\n    })\n    debugger\n  }\n\n  renderGraph(){\n    this.force = d3.layout.force()\n    .size([this.svgWidth, this.svgHeight])\n    .nodes(d3.values(this.nodes))\n    .links(this.links)\n    .on(\"tick\", () => {\n      // debugger\n      this.node.attr('cx', function(d) {\n        // debugger\n        return d.x;\n      })\n      .attr('cy', function(d) { return d.y; })\n      .attr(\"transform\", function(d) { return `translate(${d.x},${d.y})`; });\n\n      // debugger\n      this.link.attr('x1', function(d) {\n        // debugger\n        return d.source.x; })\n      .attr('y1', function(d) { return d.source.y; })\n      .attr('x2', function(d) { return d.target.x; })\n      .attr('y2', function(d) { return d.target.y; });\n\n\n      this.edgepaths.attr('d', function(d) {\n        let path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;\n        return path\n      });\n\n      this.edgelabels.attr(\"transform\", function(d,i){\n        if (d.target.x < d.source.x){\n          let bbox = this.getBBox();\n          let rx = bbox.x + bbox.width/2;\n          let ry = bbox.y + bbox.height/2;\n          return `rotate(180 ${rx} ${ry})`;\n        }\n        else{\n          return \"rotate(0)\";\n        }\n      })\n    })\n    // .linkDistance(100)\n    .gravity(0.1)\n    .charge(-1200)\n    // .linkDistance(100)\n    .linkStrength(0.4)\n    .start();\n\n    //create links\n    const infCapacity = this.infCapacity;\n    this.link = this.svgGraph.append(\"g\").selectAll('.link')\n    .data(this.links)\n    .enter().append('line')\n    .attr(\"class\", \"link\")\n    .attr('id', function(d) {\n      return `link_${d.id}`})\n      .style(\"stroke\", function(d){\n        if (d.capacity === infCapacity){\n          return \"#444\"\n        }else if (d.target.label === \"t\"){\n          if (d.capacity === 3){\n            return \"url(#rust)\"\n          }else{\n            return \"url(#stone)\"\n          }\n          // return \"#8B4513\"\n        }else if ( d.source.label === \"s\"){\n          if (d.capacity === 5){\n            return \"url(#gold)\"\n          }else{\n            return \"url(#silver)\"\n          }\n          // return \"#FFD700\"\n        }\n      })\n      .attr(\"marker-end\",\"url(#arrowhead)\")\n      .style(\"stroke-width\", d => {\n        if (d.capacity === infCapacity) return 4;\n        else return 8\n      })\n\n      //create nodes\n      this.node = this.svgGraph.selectAll(\".node\")\n      .data(this.nodes)\n      .enter().append(\"g\")\n      .attr('class', 'node')\n      // .attr(\"transform\",transform);\n      .call(this.force.drag);\n\n      //add circle to visualize nodes\n      this.node.append(\"circle\")\n      .attr('r', 12)\n      .attr(\"fill\", function(d) {\n        // debugger\n        if (d.label === \"s\"){\n          return \"#ce9308\"\n        }else if (d.label === \"t\"){\n          return \"#969696\"\n        }else if (d.profit !== null && d.profit > 0){\n          return \"#31703d\"\n        }else if (d.profit !== null && d.profit <= 0){\n          return \"#961919\"\n        }\n      })\n      .style(\"stroke\", \"#fff\")\n      .style(\"stroke-weight\", \"3\")\n\n      //add node labels\n      this.node.append(\"text\")\n      .attr(\"class\",\"nodeLabel\")\n      .attr(\"dx\", \"-.2em\")\n      .attr(\"dy\", \".35em\")\n      .style(\"fill\", \"white\")\n      .text(function(d) {return d.label})\n\n      this.edgepaths = this.svgGraph.selectAll(\".edgepath\")\n      .data(this.links)\n      .enter()\n      .append('path')\n      .attr({'d': function(d) {\n        //\n      return 'M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y},\n      'class':'edgepath',\n      'fill-opacity':0,\n      'stroke-opacity':0,\n      'fill':'blue',\n      'stroke':'red',\n      'id':function(d,i) {return `edgepath:${d.source.index}-${d.target.index}`}})\n      .style(\"pointer-events\", \"none\");\n      //\n      this.edgelabels = this.svgGraph.selectAll(\".edgelabel\")\n      .data(this.links)\n      .enter()\n      .append('text')\n      .style(\"pointer-events\", \"none\")\n      .attr({'class':'edgelabel',\n      'id':function(d,i){return 'edgelabel'+i},\n      'dx':80,\n      'dy':-7,\n      'font-size':20,\n      'fill':'#ccc'});\n      //\n      //\n      this.edgelabels.append('textPath')\n      .attr('xlink:href',function(d,i) {\n        //\n        return `#edgepath:${d.source.index}-${d.target.index}`})\n        // return '#edgepath'+i})\n        .style(\"pointer-events\", \"none\")\n        .text(function(d){\n          // `${d.capacity}`\n          let cap;\n          if (d.capacity === infCapacity){\n            cap = `∞`\n          }\n          else{\n            cap = `${d.capacity}`\n          }\n          return `${d.res}:${cap}`});\n\n\n      this.svgGraph.append('defs').append('marker')\n          .attr({'id':'arrowhead',\n                 'viewBox':'-0 -5 10 10',\n                 'refX':50,\n                 'refY':0,\n                 //'markerUnits':'strokeWidth',\n                 'orient':'auto',\n                 'markerWidth':3,\n                 'markerHeight':3,\n                 'xoverflow':'visible'})\n          .append('svg:path')\n              .attr('d', 'M 0,-5 L 10 ,0 L 0,5')\n              .attr('fill', '#ccc')\n\n    debugger\n    this.addListeners();\n    this.solver = new Solver(this.stepping, this.playback, this.count, this.matrix, this.parent, this.max_flow, this.svgGraph, this.mineSvg, this.mine);\n  }\n\n  addListeners(){\n    // document.getElementById(\"step-animation\").onclick = () => this.addRow();\n    // document.getElementById(\"play-animation\").onclick = () => this.removeRow();\n    // document.getElementById(\"stop-animation\").onclick = () => this.reset();\n  }\n}\n\nexport default Graph;\n","class Graph {\n  constructor(){\n    this.matrix = [\n        [0,1,1,1,0,0,0,0,0,0],\n        [0,0,0,0,25,25,25,0,0,0],\n        [0,0,0,0,0,25,25,25,0,0],\n        [0,0,0,0,0,0,25,25,25,0],\n        [0,0,0,0,0,0,0,0,0,1],\n        [0,0,0,0,0,0,0,0,0,1],\n        [0,0,0,0,0,0,0,0,0,1],\n        [0,0,0,0,0,0,0,0,0,1],\n        [0,0,0,0,0,0,0,0,0,1],\n        [0,0,0,0,0,0,0,0,0,0]\n      ];\n    this.mine;\n    this.mineH;\n    this.mineW;\n    this.infCapacity = 1000000;\n    this.svgWidth = 700;\n    this.svgHeight = 900;\n    this.svgGraph = d3.select(\"body\").append(\"svg\").attr(\"width\", this.svgWidth).attr(\"height\", this.svgHeight);\n\n    this.nodes = [  {label: \"s\", index: 0, profit: null, row: null, fixed: true, x: this.svgWidth/2, y: this.svgHeight-100},\n      {label: \"a\", index: 1, profit: this.matrix[0][1], row: 1, fixed: true, x: this.svgWidth/2-150, y: this.svgHeight - 325},\n      {label: \"b\", index: 2, profit: this.matrix[0][2], row: 1},\n      {label: \"c\", index: 3, profit: this.matrix[0][3], row: 1, fixed: true, x: this.svgWidth/2+150, y: this.svgHeight - 325},\n      {label: \"d\", index: 4, profit: this.matrix[4][9]*-1, row: 0, fixed: true, x: this.svgWidth/2 - 200, y: 325},\n      {label: \"e\", index: 5, profit: this.matrix[5][9]*-1, row: 0},\n      {label: \"f\", index: 6, profit: this.matrix[6][9]*-1, row: 0},\n      {label: \"g\", index: 7, profit: this.matrix[7][9]*-1, row: 0},\n      {label: \"h\", index: 8, profit: this.matrix[8][9]*-1, row: 0, fixed: true, x: this.svgWidth/2 + 200, y: 325},\n      {label: \"t\", index: 9, profit: null, row: null, fixed: true, x: this.svgWidth/2, y: 100}\n    ];\n\n    let restrictions = [\n      {source: 1, target: 4},\n      {source: 1, target: 5},\n      {source: 1, target: 6},\n      {source: 2, target: 5},\n      {source: 2, target: 6},\n      {source: 2, target: 7},\n      {source: 3, target: 6},\n      {source: 3, target: 7},\n      {source: 3, target: 8},\n    ]\n\n    this.links = [];\n    this.node;\n    this.edgepaths;\n    this.edgelabels;\n    this.link;\n    this.restrictions = [];\n    this.nodeLabelList = \"abcdefghijklmnopqruvwxyz\"\n    this.innerNodeCount = 0;\n    this.force;\n    // this.tick.bind(this);\n    //\n  }\n\n\n\n  renderGraph(){\n    // let width = 900,\n    //     height = 900;\n    //\n    // let animationInterval = 100;\n    //\n    // let matrix = [\n    //   [0,1,1,1,0,0,0,0,0,0],\n    //   [0,0,0,0,25,25,25,0,0,0],\n    //   [0,0,0,0,0,25,25,25,0,0],\n    //   [0,0,0,0,0,0,25,25,25,0],\n    //   [0,0,0,0,0,0,0,0,0,1],\n    //   [0,0,0,0,0,0,0,0,0,1],\n    //   [0,0,0,0,0,0,0,0,0,1],\n    //   [0,0,0,0,0,0,0,0,0,1],\n    //   [0,0,0,0,0,0,0,0,0,1],\n    //   [0,0,0,0,0,0,0,0,0,0]\n    // ]\n    //\n    // let nodes = [\n    //   {label: \"s\", index: 0, profit: null, row: null, fixed: true, x: width/2, y: height-100},\n    //   {label: \"a\", index: 1, profit: matrix[0][1], row: 1, fixed: true, x: width/2-150, y: height - 325},\n    //   {label: \"b\", index: 2, profit: matrix[0][2], row: 1},\n    //   {label: \"c\", index: 3, profit: matrix[0][3], row: 1, fixed: true, x: width/2+150, y: height - 325},\n    //   {label: \"d\", index: 4, profit: matrix[4][9]*-1, row: 0, fixed: true, x: width/2 - 200, y: 325},\n    //   {label: \"e\", index: 5, profit: matrix[5][9]*-1, row: 0},\n    //   {label: \"f\", index: 6, profit: matrix[6][9]*-1, row: 0},\n    //   {label: \"g\", index: 7, profit: matrix[7][9]*-1, row: 0},\n    //   {label: \"h\", index: 8, profit: matrix[8][9]*-1, row: 0, fixed: true, x: width/2 + 200, y: 325},\n    //   {label: \"t\", index: 9, profit: null, row: null, fixed: true, x: width/2, y: 100}\n    // ]\n    //\n    // let links = [\n    // ]\n    //\n    // //defines the u -> v edges, i.e. must complete project v before starting project u\n    // let restrictions = [\n    //   {source: 1, target: 4},\n    //   {source: 1, target: 5},\n    //   {source: 1, target: 6},\n    //   {source: 2, target: 5},\n    //   {source: 2, target: 6},\n    //   {source: 2, target: 7},\n    //   {source: 3, target: 6},\n    //   {source: 3, target: 7},\n    //   {source: 3, target: 8},\n    // ]\n    //\n    // //effectively the sum of all other capacities + 1 (commonly C + 1)\n    // let infCapacity = 1000000;\n    //\n    // //computes C + 1\n    // const simulateInfCapacity = () => {\n    //   nodes.forEach(node => {\n    //     if (node.profit !== null){\n    //       if (node.profit > 0){\n    //         infCapacity = infCapacity + node.profit\n    //       }else{\n    //         infCapacity = infCapacity - node.profit\n    //       }\n    //     }\n    //   })\n    //   infCapacity = infCapacity + 1;\n    // }\n    //\n    // let linkIdIdx = 0;\n    // //creates links with finite capacities\n    // const setFiniteLinks = () => {\n    //   nodes.forEach((node,i) => {\n    //     //\n    //     if (node.label !== \"s\" && node.label !== \"t\"){\n    //       if (node.profit > 0){\n    //         links.push({source: 0, target: i, res: 0, capacity: node.profit})\n    //       }else{\n    //         links.push({source: i, target: (nodes.length-1), capacity: (-1 * node.profit), res: 0, id: linkIdIdx})\n    //       }\n    //     }\n    //     linkIdIdx = linkIdIdx + 1;\n    //   })\n    // }\n    // //creates links with infinite capacities\n    // const setInfiniteLinks = () => {\n    //   restrictions.forEach(restriction => {\n    //     links.push({source: restriction.source, target: restriction.target, res: 0, capacity: infCapacity, id: linkIdIdx})\n    //     linkIdIdx = linkIdIdx + 1;\n    //   })\n    // }\n    // // simulateInfCapacity();\n    // setInfiniteLinks();\n    // setFiniteLinks();\n    //\n\n    //create object for manipulation\n    this.svgGraph = d3.select('body').append('svg')\n        .attr('width', this.svgWidth)\n        .attr('height', this.svgHeight);\n\n    //\n    //apply force conditions\n\n    this.force = d3.layout.force()\n        .size([this.svgWidth, this.svgHeight])\n        .nodes(d3.values(this.nodes))\n        .links(this.links)\n        .on(\"tick\", () => {\n          // debugger\n          this.node.attr('cx', function(d) {\n            // debugger\n              return d.x;\n            })\n            .attr('cy', function(d) { return d.y; })\n            .attr(\"transform\", function(d) { return `translate(${d.x},${d.y})`; });\n\n      // debugger\n      this.link.attr('x1', function(d) { return d.source.x; })\n          .attr('y1', function(d) { return d.source.y; })\n          .attr('x2', function(d) { return d.target.x; })\n          .attr('y2', function(d) { return d.target.y; });\n\n\n          this.edgepaths.attr('d', function(d) {\n            let path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;\n            return path\n          });\n\n          // edgelabels.attr('transform',function(d,i){\n          //     if (d.target.x<d.source.x){\n          //         bbox = this.getBBox();\n          //         rx = bbox.x+bbox.width/2;\n          //         ry = bbox.y+bbox.height/2;\n          //         return 'rotate(180 '+rx+' '+ry+')';\n          //         }\n          //     else {\n          //         return 'rotate(0)';\n          //         }\n          // });\n\n          this.edgelabels.attr(\"transform\", function(d,i){\n            if (d.target.x < d.source.x){\n              let bbox = this.getBBox();\n              let rx = bbox.x + bbox.width/2;\n              let ry = bbox.y + bbox.height/2;\n              return `rotate(180 ${rx} ${ry})`;\n            }\n            else{\n              return \"rotate(0)\";\n            }\n          })\n        })\n        // .linkDistance(100)\n        .gravity(0.1)\n        .charge(-1200)\n        .linkDistance(120)\n        .linkStrength(0.1)\n        .start();\n\n        // link.append(\"linkLabel\")\n        //   .append(\"text\")\n        //   .attr(\"class\",\"linkLabel\")\n        //   .attr(\"x\",\"50\")\n        //   .attr(\"y\",\"-20\")\n        //   .attr(\"text-anchor\",\"start\")\n        //   .style(\"fill\",\"#000\")\n        //   .attr(\"xlink:href\",function(d,i){\n        //\n        //     return `#linkId_${i}`;})\n        //   .text(function(d) {\n        //     return d.id;\n        //   })\n\n    //create links\n    this.link = this.svgGraph.append(\"g\").selectAll('.link')\n        .data(this.links)\n        .enter().append('line')\n        .attr(\"class\", \"link\")\n        .attr('id', function(d) {\n          return `link_${d.id}`})\n        .style(\"stroke\", function(d){\n          if (d.capacity === this.infCapacity){\n            return \"#000\"\n          }else if (d.target.label === \"t\"){\n            return \"#632f12\"\n          }else if ( d.source.label === \"s\"){\n            return \"#fff\"\n          }\n        })\n        // .attr(\"marker-end\",\"url(#arrowhead)\")\n        .style(\"stroke-width\", \"4\")\n\n        //create nodes\n        this.node = this.svgGraph.selectAll(\".node\")\n        .data(this.nodes)\n        .enter().append(\"g\")\n        .attr('class', 'node')\n        // .attr(\"transform\",transform);\n        .call(this.force.drag);\n\n        //add circle to visualize nodes\n        this.node.append(\"circle\")\n        .attr('r', 12)\n        .attr(\"fill\", function(d) {\n          if (d.label === \"s\"){\n            return \"#ce9308\"\n          }else if (d.label === \"t\"){\n            return \"#969696\"\n          }else if (d.profit !== null && d.profit > 0){\n            return \"#31703d\"\n          }else if (d.profit !== null && d.profit <= 0){\n            return \"#961919\"\n          }\n        })\n        .style(\"stroke\", \"#fff\")\n        .style(\"stroke-weight\", \"3\")\n\n        //add node labels\n        this.node.append(\"text\")\n        .attr(\"class\",\"nodeLabel\")\n        .attr(\"dx\", \"-.2em\")\n        .attr(\"dy\", \".35em\")\n        .style(\"fill\", \"white\")\n        .text(function(d) {return d.label})\n\n    this.edgepaths = this.svgGraph.selectAll(\".edgepath\")\n        .data(this.links)\n        .enter()\n        .append('path')\n        .attr({'d': function(d) {\n          //\n          return 'M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y},\n               'class':'edgepath',\n               'fill-opacity':0,\n               'stroke-opacity':0,\n               'fill':'blue',\n               'stroke':'red',\n               'id':function(d,i) {return `edgepath:${d.source.index}-${d.target.index}`}})\n        .style(\"pointer-events\", \"none\");\n    //\n        this.edgelabels = this.svgGraph.selectAll(\".edgelabel\")\n            .data(this.links)\n            .enter()\n            .append('text')\n            .style(\"pointer-events\", \"none\")\n            .attr({'class':'edgelabel',\n                   'id':function(d,i){return 'edgelabel'+i},\n                   'dx':80,\n                   'dy':-5,\n                   'font-size':20,\n                   'fill':'#aaa'});\n    //\n    //\n         this.edgelabels.append('textPath')\n             .attr('xlink:href',function(d,i) {\n               //\n                return `#edgepath:${d.source.index}-${d.target.index}`})\n               // return '#edgepath'+i})\n             .style(\"pointer-events\", \"none\")\n             .text(function(d){\n               // `${d.capacity}`\n               let cap;\n               if (d.capacity === this.infCapacity){\n                 cap = `∞`\n               }\n               else{\n                 cap = `${d.capacity}`\n               }\n               return `${d.res}:${cap}`});\n\n  }\n\n  // tick(e) {\n  //   this;\n  //\n  //     this.node.attr('cx', function(d) {\n  //         return d.x;\n  //       })\n  //       .attr('cy', function(d) { return d.y; })\n  //       .attr(\"transform\", function(d) { return `translate(${d.x},${d.y})`; });\n  //\n  //     this.link.attr('x1', function(d) { return d.source.x; })\n  //         .attr('y1', function(d) { return d.source.y; })\n  //         .attr('x2', function(d) { return d.target.x; })\n  //         .attr('y2', function(d) { return d.target.y; });\n  //\n  //\n  //     this.edgepaths.attr('d', function(d) {\n  //       let path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;\n  //       return path\n  //     });\n  //\n  //     this.edgelabels.attr(\"transform\", function(d,i){\n  //       if (d.target.x < d.source.x){\n  //         let bbox = this.getBBox();\n  //         let rx = bbox.x + bbox.width/2;\n  //         let ry = bbox.y + bbox.height/2;\n  //         return `rotate(180 ${rx} ${ry})`;\n  //       }\n  //       else{\n  //         return \"rotate(0)\";\n  //       }\n  //     })\n  // }\n\n}\n\nexport default Graph;\n","import Graph from \"./graph.js\";\n\nclass Mine {\n  constructor(){\n    this.mine = [\n      // [\n      //   {profit: -1, idx: 3},\n      //   {profit: -1, idx: 4},\n      //   {profit: -1, idx: 5},\n      //   {profit: -1, idx: 6},\n      //   {profit: -1, idx: 7}\n      // ],\n      // [\n      //   {profit: null, idx: null},\n      //   {profit: 1, idx: 0},\n      //   {profit: 1, idx: 1},\n      //   {profit: 1, idx: 2},\n      //   {profit: null, idx: null}\n      // ]\n      // [\n      //   {profit: -1, idx: 15},\n      //   {profit: -1, idx: 16},\n      //   {profit: -1, idx: 17},\n      //   {profit: -1, idx: 18},\n      //   {profit: -1, idx: 19}\n      // ],\n\n\n      // [\n      //   {profit: -1, idx: 12},\n      //   {profit: -1, idx: 13},\n      //   {profit: -1, idx: 14},\n      //   {profit: -1, idx: 15},\n      //   {profit: -1, idx: 16},\n      //   {profit: -1, idx: 17},\n      //   // {profit: -1, idx: 14}\n      // ],\n      [\n        {profit: -3, idx: 7},\n        {profit: -1, idx: 8},\n        {profit: -3, idx: 9},\n        {profit: -3, idx: 10},\n        {profit: -3, idx: 11},\n        // {profit: -2, idx: 14}\n      ],\n      [\n        {profit: -1, idx: 3},\n        {profit: 2, idx: 4},\n        {profit: 5, idx: 5},\n        {profit: 5, idx: 6},\n        // {profit: -1, idx: 9}\n      ],\n      [\n        {profit: 5, idx: 0},\n        {profit: 5, idx: 1},\n        {profit: 2, idx: 2},\n        // {profit: 1, idx: 4}\n      ]\n    ];\n    this.currentProfit = 0;\n    this.guessing = true;\n    this.blockLabelList = \"abcdefghijklmnopqruvwxyz\"\n    this.nodeLayers;\n    this.updateNodeLayers(this.mine);\n    // debugger\n    this.numBlocks = 0;\n    this.findNumBlocks();\n    this.block;\n    this.svg = d3.select(\".svgMineBody\").append(\"svg\").attr(\"class\",\"mineSvg\").attr(\"width\", 700).attr(\"height\", window.innerHeight-450)\n    this.svgKeys = d3.select(\".svgKeys\").append(\"svg\").attr(\"class\",\"keysSvg\").attr(\"width\", 700).attr(\"height\", 170)\n    this.blocks = [];\n    this.blockSelectors = [\n      {id: 0, color: \"#FFD700\", profit: 5, type: \"selector\", texture: \"gold\"},\n      {id: 1, color: \"#c8c8c8\", profit: 2, type: \"selector\", texture: \"silver\"},\n      {id: 2, color: \"#bdad9c\", profit: -1, type: \"selector\", texture: \"stone\"},\n      {id: 3, color: \"#8B4513\", profit: -3, type: \"selector\", texture: \"rust\"},\n      // {id: 3, color: \"#8B4513\", profit: -1, type: \"selector\", texture: \"rust\"}\n    ];\n    this.currentBlockType = this.blockSelectors[1];\n    this.drawMine();\n    // this.addListeners();\n    this.graph = new Graph(this.svg);\n    this.graph.generateMatrixFromMine(this);\n    this.graph.populateLinks();\n    this.presentGraph();\n    // this.graph.generateMatrixFromMine(this);\n    //\n    // this.graph.populateLinks(this.mine);\n    // this.presentGraph();\n  }\n\n  findNumBlocks(){\n    this.numBlocks = 0;\n    this.mine.forEach(row=>{\n      row.forEach(() => this.numBlocks++)\n    });\n  }\n\n  updateNodeLayers(mine){\n    const result = [];\n    mine.forEach(row => {\n      const rowEnds = [];\n      let first = 0;\n      while (first < row.length){\n        if(row[first].profit !== null){\n          rowEnds.push(row[first].idx);\n          break;\n        }\n        first++;\n      }\n      let last = row.length-1;\n      while (last > 0){\n        if(row[last].profit !== null){\n          rowEnds.push(row[last].idx);\n          break;\n        }\n        last--;\n      }\n      result.push(rowEnds);\n      // debugger\n    })\n    this.nodeLayers = result;\n    // debugger\n  }\n\n  findIndexFromRowCol(row,col){\n    let minRow = this.mine[this.mine.length-1].length;\n    let height = this.mine.length;\n    let offset;\n    if (row === this.mine.length - 1){\n      offset = 0;\n    }else{\n      let n = height-2-row;\n      offset = (n*(n+1))/2;\n    }\n    return minRow*(height-1-row) + col + 1 + offset;\n  }\n\n  drawMine(){\n    let defs = this.svg.append(\"defs\");\n\n    defs.append(\"pattern\")\n    .attr(\"id\", \"gold\")\n    .attr(\"height\",\"100%\")\n    .attr(\"width\",\"100%\")\n    .attr(\"patternContentUnits\",\"objectBoundingBox\")\n    .append(\"image\")\n    .attr(\"height\", 1)\n    .attr(\"width\", 1)\n    .attr(\"preserveAspectRatio\", \"none\")\n    .attr(\"xlink:href\",\"gold.jpg\");\n    defs.append(\"pattern\")\n    .attr(\"id\", \"rust\")\n    .attr(\"height\",\"100%\")\n    .attr(\"width\",\"100%\")\n    .attr(\"patternContentUnits\",\"objectBoundingBox\")\n    .append(\"image\")\n    .attr(\"height\", 1)\n    .attr(\"width\", 1)\n    .attr(\"preserveAspectRatio\", \"none\")\n    .attr(\"xlink:href\",\"rust.jpeg\");\n    defs.append(\"pattern\")\n    .attr(\"id\", \"silver\")\n    .attr(\"height\",\"100%\")\n    .attr(\"width\",\"100%\")\n    .attr(\"patternContentUnits\",\"objectBoundingBox\")\n    .append(\"image\")\n    .attr(\"height\", 1)\n    .attr(\"width\", 1)\n    .attr(\"preserveAspectRatio\", \"none\")\n    .attr(\"xlink:href\",\"silver.jpg\");\n    defs.append(\"pattern\")\n    .attr(\"id\", \"stone\")\n    .attr(\"height\",\"100%\")\n    .attr(\"width\",\"100%\")\n    .attr(\"patternContentUnits\",\"objectBoundingBox\")\n    .append(\"image\")\n    .attr(\"height\", 1)\n    .attr(\"width\", 1)\n    .attr(\"preserveAspectRatio\", \"none\")\n    .attr(\"xlink:href\",\"stone.jpg\");\n    // console.log(5);\n    this.mine.forEach((row,i) => {\n      row.forEach((block,j) => {\n        let color;\n        if (block.profit === null){\n          color = \"black\";\n        }else{\n          color = this.blockSelectors.filter(obj => {\n            return obj.profit === block.profit\n          })[0].color\n        }\n        // debugger\n        this.blocks.push({profit: block.profit, row: i, col: j, color, type: block, border: \"black\"})\n      })\n    })\n\n    let width = 50;\n    this.mine\n\n    this.block = this.svg.selectAll(\".block\")\n    .data(this.blocks)\n    .enter().append(\"g\")\n    .attr(\"class\",\"block\")\n\n    this.svg.append(\"text\")\n    .attr(\"class\",\"profit\")\n    .attr(\"transform\", d => {\n      return `translate(${120}, ${60})`\n    })\n    .attr(\"id\", `profit`)\n    .attr(\"dx\", \"3.2em\")\n    .attr(\"dy\", \"1em\")\n    .style(\"fill\", d => \"white\")\n    .text((d) => `Your Current Profit: $${this.currentProfit}k`)\n    .style(\"font-weight\", 600)\n    .style(\"font-size\", 24)\n    .style(\"stroke-width\",0)\n\n    // debugger\n    this.block.append(\"rect\")\n    .attr(\"x\", (d) => {\n      return 100 + d.row*50 + 102*d.col + (3 - this.mine.length)*50\n    })\n    .attr(\"y\", function(d){\n      return 198 + 102*d.row\n    })\n    .attr(\"id\",function(d){\n      return `rect:${d.row}-${d.col}`\n    })\n    .attr(\"width\", 100)\n    .attr(\"height\", 100)\n    .attr(\"fill\",function(d){\n      if (d.profit === null){\n        return \"black\"\n      }\n      else if (d.profit === 5){\n        return \"url(#gold)\"\n      }else if (d.profit === -3){\n        return \"url(#rust)\"\n      }else if (d.profit === 2){\n        return \"url(#silver)\"\n      }else if (d.profit === -1){\n        return \"url(#stone)\"\n      }\n    })\n    .style(\"stroke\",\"black\")\n    .style(\"stroke-width\", 2)\n\n    this.block.append(\"text\")\n    .attr(\"class\",\"blockLabel\")\n    .attr(\"transform\", d => {\n      return `translate(${100 + d.row*50 + 100*d.col + (3 - this.mine.length)*50}, ${200 + 100*d.row})`\n    })\n    .attr(\"id\",function(d){\n      return `blockLabel:${d.row}-${d.col}`\n    })\n    .attr(\"dx\", \"3.2em\")\n    .attr(\"dy\", \"1em\")\n    .style(\"fill\", d => {\n      if (d.profit > 0) return \"green\"\n      else return \"red\"\n    })\n    .text((d) => {\n      debugger\n      return this.blockLabelList[this.findIndexFromRowCol(d.row,d.col)-1]})\n    .style(\"font-weight\", 600)\n    .style(\"font-size\", 24)\n\n\n    let circleSelector = this.svgKeys.selectAll(\".circleSelector\")\n    .data(this.blockSelectors)\n    .enter().append(\"g\")\n    .attr(\"class\",\"circleSelector\")\n\n    circleSelector.append(\"circle\")\n    .attr(\"id\",function(d){return `circleSelector:${d.id}`})\n    .attr(\"cx\",function(d){return 250+d.id*100})\n    .attr(\"cy\", 50)\n    .attr(\"r\",20)\n    .attr(\"fill\",function(d){\n      return `url(#${d.texture})`\n    })\n\n    // circleSelector.filter(d => d.id === 1)\n    // .style(\"stroke\", \"red\")\n    // .style(\"stroke-width\", 3);\n\n    circleSelector.append(\"text\")\n    .attr(\"class\",\"selectorLabel\")\n    .attr(\"transform\", d => {\n      return `translate(${150+d.id*100}, ${75})`\n    })\n    .attr(\"id\",function(d){\n      return `selectorLabel:${d.id}`\n    })\n    .attr(\"dx\", \"3.2em\")\n    .attr(\"dy\", \"1em\")\n    .style(\"fill\", d => {\n      if (d.profit > 0) return \"green\";\n      else return \"red\";\n    })\n    .text((d) => {\n      if (d.profit > 0){\n        return `+$${d.profit}k`\n      }else{\n        return `-$${-1 * d.profit}k`\n      }\n    })\n    .style(\"font-weight\", 600)\n    .style(\"font-size\", 24)\n    .style(\"stroke-width\",0)\n\n    circleSelector.append(\"text\")\n    .attr(\"class\",\"selectorLabel\")\n    .attr(\"transform\", d => {\n      return `translate(${165+d.id*100}, ${0})`\n    })\n    .attr(\"id\",function(d){\n      return `selectorLabel:${d.id}`\n    })\n    .attr(\"dx\", \"3.2em\")\n    .attr(\"dy\", \"1em\")\n    .style(\"fill\", d => `url(#${d.texture})`)\n    .text((d) => {\n      if (d.profit === 5){\n        return \"Gold\"\n      }else if (d.profit === 2){\n        return \"Silver\"\n      }else if (d.profit === -1){\n        return \"Stone\"\n      }else if (d.profit === -3){\n        return \"Rust\"\n      }\n    })\n    .style(\"font-weight\", 600)\n    .style(\"font-size\", 20)\n    .style(\"stroke-width\",0)\n\n    circleSelector.filter(d => d.profit === 5)\n    .append(\"text\")\n    .attr(\"class\",\"selectorLabel\")\n    .attr(\"transform\", d => {\n      return `translate(${50}, ${25})`\n    })\n    .attr(\"id\",function(d){\n      return `selector-instructions`\n    })\n    .attr(\"dx\", \"3.2em\")\n    .attr(\"dy\", \"1em\")\n    .style(\"fill\", d => \"white\")\n    .text((d) => {\n      return \"Key:\"\n    })\n    .style(\"font-weight\", 400)\n    .style(\"font-size\", 24)\n    .style(\"stroke-width\",0)\n\n    // circleSelector.filter(d => d.profit === 5)\n    // .append(\"text\")\n    // .attr(\"class\",\"selectorLabel\")\n    // .attr(\"transform\", d => {\n    //   return `translate(${-50}, ${50})`\n    // })\n    // .attr(\"id\",function(d){\n    //   return `selector-instructions`\n    // })\n    // .attr(\"dx\", \"3.2em\")\n    // .attr(\"dy\", \"1em\")\n    // .style(\"fill\", d => \"white\")\n    // .text((d) => {\n    //   return \"clicking a button to the right and\"\n    // })\n    // .style(\"font-weight\", 400)\n    // .style(\"font-size\", 18)\n    // .style(\"stroke-width\",0)\n    //\n    // circleSelector.filter(d => d.profit === 5)\n    // .append(\"text\")\n    // .attr(\"class\",\"selectorLabel\")\n    // .attr(\"transform\", d => {\n    //   return `translate(${-50}, ${75})`\n    // })\n    // .attr(\"id\",function(d){\n    //   return `selector-instructions`\n    // })\n    // .attr(\"dx\", \"3.2em\")\n    // .attr(\"dy\", \"1em\")\n    // .style(\"fill\", d => \"white\")\n    // .text((d) => {\n    //   return \"selecting specific blocks below\"\n    // })\n    // .style(\"font-weight\", 400)\n    // .style(\"font-size\", 18)\n    // .style(\"stroke-width\",0)\n\n   //  let invisiNodes = [\n   //    {x: 650, y: 0},\n   //    {x: 650, y: 50}\n   //  ]\n   //  //\n   //\n   //  let invisiNode = this.svg.selectAll('.node')\n   //  .data(invisiNodes)\n   //  .enter().append('circle')\n   //  .attr('class', 'node');\n   //\n   //  let links = [\n   //    { source: 0, target: 1 }\n   //  ];\n   //\n   //  invisiNode.attr('r', 0)\n   //     .attr('cx', function(d) { return d.x; })\n   //     .attr('cy', function(d) { return d.y; });\n   //\n   //  let link = this.svg.append('g').selectAll('.link')\n   //  .data(links)\n   //  .enter().append(\"line\")\n   //  .attr('class', 'link')\n   //  .style(\"stroke\",\"white\")\n   //  .style(\"stroke-width\", 3)\n   //  .attr(\"marker-end\",\"url(#arrowheadMine)\")\n   //  //\n   //\n   //  link.attr('x1', 650)\n   //     .attr('y1', 125)\n   //     .attr('x2', 650)\n   //     .attr('y2', 400);\n   //\n   // defs.append('marker')\n   //     .attr({'id':'arrowheadMine',\n   //            'viewBox':'-0 -5 10 10',\n   //            'refX':0,\n   //            'refY':0,\n   //            //'markerUnits':'strokeWidth',\n   //            'orient':'auto',\n   //            'markerWidth':10,\n   //            'markerHeight':10,\n   //            'xoverflow':'visible'})\n   //     .append('svg:path')\n   //         .attr('d', 'M 0,-5 L 10 ,0 L 0,5')\n   //         .attr('fill', '#fff')\n   //\n   //         let edgepaths = this.svg.selectAll(\".edgepath\")\n   //         .data(links)\n   //         .enter()\n   //         .append('path')\n   //         .attr({'d': function(d) {\n   //           //\n   //         return 'M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y},\n   //         'class':'edgepathMine',\n   //         'fill-opacity':0,\n   //         'stroke-opacity':0,\n   //         'fill':'blue',\n   //         'stroke':'red',\n   //         'id':function(d,i) {return `edgepath:depth`}})\n   //         .style(\"pointer-events\", \"none\");\n   //         //\n   //         let edgelabels = this.svg.selectAll(\".edgelabelMine\")\n   //         .data(links)\n   //         .enter()\n   //         .append('text')\n   //         .style(\"pointer-events\", \"none\")\n   //         .attr({'class':'edgelabelMine',\n   //         'id':function(d){return 'edgelabelMine'},\n   //         'dx':80,\n   //         'dy':-7,\n   //         'font-size':20,\n   //         'fill':'#ccc'});\n   //         //\n   //         //\n   //         edgelabels.append('textPath')\n   //         .attr('xlink:href',function(d,i) {\n   //           //\n   //           return `#edgepath:depth`})\n   //           // return '#edgepath'+i})\n   //           .style(\"pointer-events\", \"none\")\n   //           .text(\"heeey\");\n\n    // .attr(\"fill\",function(d){return d.color})\n    //\n    // this.svg.append(\"circle\")\n    // .attr(\"id\",\"addRow\")\n    // .attr(\"cx\", 250)\n    // .attr(\"cy\", 35)\n    // .attr(\"r\", 25)\n    // .attr(\"fill\", \"green\")\n    //\n    // this.svg.append(\"circle\")\n    // .attr(\"id\",\"removeRow\")\n    // .attr(\"cx\", 310)\n    // .attr(\"cy\", 35)\n    // .attr(\"r\", 25)\n    // .attr(\"fill\", \"red\")\n\n    this.addListeners();\n  }\n\n  presentGraph(){\n    this.graph.renderGraph();\n    // this.graph.addListeners();\n  }\n\n  clearMine(){\n    d3.select(\".mineSvg\").selectAll(\"*\")\n    // .filter(d => {\n    //   return typeof d !== \"undefined\" && d.type !== \"selector\"\n    // })\n    .remove();\n    this.blocks = [];\n  }\n\n  addRow(){\n    if (this.mine.length < 4) {\n      let index = this.numBlocks;\n      let newRow = [];\n      for (let i = 0; i <= this.mine[0].length; i++){\n        newRow.push({profit: -1, idx: index});\n        index++;\n        this.numBlocks++;\n      }\n      this.mine.unshift(newRow);\n      this.updateNodeLayers(this.mine);\n      this.clearMine();\n      this.drawMine();\n      this.graph.clearGraph();\n      this.graph.generateMatrixFromMine(this);\n      this.graph.populateLinks();\n      this.presentGraph();\n    }\n  }\n\n  removeRow(){\n    if (this.mine.length > 1){\n      this.mine.shift();\n      this.findNumBlocks();\n      this.updateNodeLayers(this.mine);\n      this.clearMine();\n      this.drawMine();\n      // debugger\n      this.graph.clearGraph();\n      this.graph.generateMatrixFromMine(this);\n      this.graph.populateLinks();\n      this.presentGraph();\n    }\n  }\n\n  findPadding(row){\n    let topLength = 3 + this.mine.length - 1;\n    let sum = 0;\n    let rowCp = row;\n    while (rowCp > 0){\n      sum += topLength;\n      topLength--;\n      rowCp--;\n    }\n    return sum;\n  }\n\n  findBlockIndex(row,col){\n    return col + this.findPadding(row);\n  }\n\n  reset(){\n    this.mine =  [\n      [\n        {profit: -3, idx: 7},\n        {profit: -1, idx: 8},\n        {profit: -3, idx: 9},\n        {profit: -3, idx: 10},\n        {profit: -3, idx: 11},\n        // {profit: -2, idx: 14}\n      ],\n      [\n        {profit: -1, idx: 3},\n        {profit: 2, idx: 4},\n        {profit: 5, idx: 5},\n        {profit: 5, idx: 6},\n        // {profit: -1, idx: 9}\n      ],\n      [\n        {profit: 5, idx: 0},\n        {profit: 5, idx: 1},\n        {profit: 2, idx: 2},\n        // {profit: 1, idx: 4}\n      ]\n    ];\n    this.updateNodeLayers(this.mine);\n    this.clearMine();\n    this.drawMine();\n    this.graph.clearGraph();\n    this.graph.generateMatrixFromMine(this);\n    this.graph.populateLinks();\n    this.presentGraph();\n  }\n\n  rectify(row,col){\n    return `rect:${row}-${col}`\n  }\n\n  findAboves(id){\n    const result = [id];\n    const splat = id.split(new RegExp('(:|-)'));\n    const row = Number(splat[2]);\n    const col = Number(splat[4]);\n    // debugger\n    let count = 0;\n    while (count < row){\n      count++;\n      for (let k = 0; k <= count; k++){\n        result.push(this.rectify(row-count,k+col));\n      }\n    }\n    return result;\n  }\n\n  addListeners(){\n    const html = document.getElementById(\"body\");\n\n    // document.getElementById(\"add-row\").onclick = () => this.addRow();\n    // document.getElementById(\"remove-row\").onclick = () => this.removeRow();\n    // document.getElementById(\"reset-graph-and-mine\").onclick = () => this.reset();\n    // document.getElementById(\"select-guess\").onclick = () => {\n    //   // html.classList.toggle('active');\n    //   this.guessing = true\n    // };\n\n    this.blocks.forEach(block => {\n      if (block.profit !== null){\n        let tmpBlock = document.getElementById(`rect:${block.row}-${block.col}`)\n\n\n        // let tmpColor;\n        tmpBlock.addEventListener(\"mouseover\",(e) => {\n          if (this.guessing){\n            const aboves = this.findAboves(e.currentTarget.id)\n            // debugger\n            this.svg.selectAll(\"rect\").filter(function(d){\n              return aboves.includes(`rect:${d.row}-${d.col}`);\n            })\n            .style(\"stroke\", \"red\")\n            .style(\"stroke-width\", 2)\n          }\n        })\n        //\n        tmpBlock.addEventListener(\"mouseout\",(e) => {\n          if (this.guessing){\n            const aboves = this.findAboves(e.currentTarget.id)\n            this.svg.selectAll(\"rect\").filter(function(d){\n              return aboves.includes(`rect:${d.row}-${d.col}`);\n            })\n            .style(\"stroke\", d => d.border)\n            .style(\"stroke-width\", 2)\n          }\n        })\n\n        // this.guessing = false;\n        // html.classList.toggle('active');\n        tmpBlock.addEventListener(\"click\", e => {\n          if (this.guessing){\n            const aboves = this.findAboves(e.currentTarget.id)\n            this.svg.selectAll(\"rect\").filter((d) => {\n              // debugger\n              if (aboves.includes(`rect:${d.row}-${d.col}`)){\n                debugger\n                if (d.border === \"black\") this.currentProfit = this.currentProfit + d.profit;\n                return true;\n              }else{\n                return false;\n              }\n            })\n            .style(\"stroke\", d => {\n              this.blocks[this.findBlockIndex(d.row,d.col)].border = \"red\";\n              return \"red\"\n            })\n            .style(\"stroke-width\", 2)\n\n            this.svg.selectAll(\".profit\").transition().duration(1).text(`Your Current Profit: $${this.currentProfit}k`)\n          }else{\n            let updatableObj;\n            this.svg.selectAll(\"rect\").filter((d) => {\n              // debugger\n              if (typeof d !== \"undefined\" && `rect:${d.row}-${d.col}` === e.currentTarget.id){\n                // this.mine[d.row][d.col].color = this.currentBlockType.color;\n                updatableObj = this.blocks.filter(block => (block.col === d.col && block.row === d.row))[0];\n                updatableObj.profit = this.currentBlockType.profit;\n                updatableObj.color = this.currentBlockType.color\n\n                return true;\n              }\n            })\n            .attr(\"fill\",`url(#${this.currentBlockType.texture})`)\n            // .style(\"stroke\", \"red\")\n            // .style(\"stroke-width\", 2);\n\n            // debugger\n            this.svg.selectAll(\".blockLabel\")\n            .filter(d => {return (d.row === updatableObj.row && d.col === updatableObj.col)})\n            .style(\"fill\",d => {\n              if (this.currentBlockType.profit > 0){\n                return \"green\"\n              }else{\n                return \"red\"\n              }\n            })\n            let indices = e.currentTarget.id.split(\":\")[1].split(\"-\");\n            // debugger\n            this.mine[Number(indices[0])][Number(indices[1])].profit = this.currentBlockType.profit;\n\n            this.graph.clearGraph();\n            this.graph.generateMatrixFromMine(this);\n            this.graph.populateLinks();\n            this.presentGraph();\n          }\n\n\n          // debugger\n          // this.svg.selectAll(\".block\").attr(\"fill\",\"white\");\n        })\n        //\n      }\n      })\n\n      // this.blockSelectors.forEach(selector => {\n      //   // debugger\n      //   let tmpSelector = document.getElementById(`circleSelector:${selector.id}`)\n      //   tmpSelector.addEventListener(\"click\", e => {\n      //     if (this.guessing) {\n      //       this.guessing = false;\n      //       // debugger\n      //\n      //       // html.classList.toggle('active');\n      //     }\n      //     this.svg.selectAll(\".circleSelector\")\n      //     .style(\"stroke-width\", \"3\")\n      //     .style(\"stroke\",(d) => {\n      //       if (e.currentTarget.id.split(\":\")[1] === `${d.id}`){\n      //         this.currentBlockType = d;\n      //         // debugger\n      //         return \"red\";\n      //       }else{\n      //         // debugger\n      //         return \"none\";\n      //       }\n      //       // debugger\n      //     })\n      //     // debugger\n      //   }\n      // )}\n    // )\n\n    // let addRow = document.getElementById(\"addRow\");\n    // addRow.addEventListener(\"click\", e => {\n    //   debugger\n    //   if (this.mine.length < 4) {\n    //     let index = this.numBlocks;\n    //     let newRow = [];\n    //     for (let i = 0; i <= this.mine[0].length; i++){\n    //       newRow.push({profit: -1, idx: index});\n    //       index++;\n    //       this.numBlocks++;\n    //     }\n    //     this.mine.unshift(newRow);\n    //     this.updateNodeLayers(this.mine);\n    //     this.clearMine();\n    //     debugger\n    //     this.drawMine();\n    //     this.graph.clearGraph();\n    //     this.graph.generateMatrixFromMine(this);\n    //     this.graph.populateLinks();\n    //     this.presentGraph();\n    //   }\n    // })\n    //\n    // let removeRow = document.getElementById(\"removeRow\");\n    // removeRow.addEventListener(\"click\", e =>{\n    //   debugger\n    //   if (this.mine.length > 1){\n    //     this.mine.shift();\n    //     this.findNumBlocks();\n    //     this.updateNodeLayers(this.mine);\n    //     this.clearMine();\n    //     this.drawMine();\n    //     debugger\n    //     this.graph.clearGraph();\n    //     this.graph.generateMatrixFromMine(this);\n    //     this.graph.populateLinks();\n    //     this.presentGraph();\n    //   }\n    // })\n\n  }\n}\n\nexport default Mine;\n","// // const Vertex = require(\"./vertex.js\");\n// const Vertex = require(\"./vertex.js\");\n//\n// // import Vertex from \"./vertex.js\";\n//\n// document.addEventListener(\"DOMContentLoaded\", () => {\n//   const canvas = document.getElementById(\"canvas\");\n//   const ctx = canvas.getContext(\"2d\");\n//\n//   // const Vertex = function(x,y,r){\n//   //   this.x = x,\n//   //   this.y = y,\n//   //   this.r = r\n//   // }\n//   //\n//   // Vertex.prototype.render = function(ctx){\n//   //   ctx.beginPath();\n//   //   ctx.arc(this.x,this.y,this.r,0,2*Math.PI);\n//   //   ctx.fillStyle = \"red\";\n//   //   ctx.fill();\n//   // }\n//\n//   const Edge = function(v1, v2){\n//     this.v1 = v1;\n//     this.v2 = v2;\n//   }\n//\n//   Edge.prototype.render = function(ctx){\n//     ctx.beginPath();\n//     ctx.moveTo(this.v1.x,this.v1.y);\n//     ctx.lineTo(this.v2.x,this.v2.y);\n//     ctx.lineWidth = 10;\n//     ctx.strokeStyle = \"purple\";\n//     ctx.stroke();\n//   }\n//\n//   const EdgeArrow = function(v1,v2){\n//\n//   }\n//\n//   const matrix = [\n//     [0,0,1,1,1,0],\n//     [0,0,0,1,1,1],\n//     [0,0,0,0,0,0],\n//     [0,0,0,0,0,0],\n//     [0,0,0,0,0,0],\n//     [0,0,0,0,0,0]\n//   ]\n//\n//   const vertices = [\n//     new Vertex(300,300,20),\n//     new Vertex(500,300,20),\n//\n//     new Vertex(100,100,20),\n//     new Vertex(300,100,20),\n//     new Vertex(500,100,20),\n//     new Vertex(700,100,20)\n//   ]\n//   const edges = [];\n//\n//   const generateEdgesFromMatrix = function(matrix){\n//     matrix.forEach((row, i) => {\n//       row.forEach((el, j) => {\n//         if (el > 0){\n//           edges.push(new Edge(vertices[i],vertices[j]));\n//         }\n//       })\n//     })\n//   }\n//\n//   generateEdgesFromMatrix(matrix);\n//\n//\n//   // const edges = [\n//   //   new Edge(vertices[4],vertices[0]),\n//   //   new Edge(vertices[4],vertices[1]),\n//   //   new Edge(vertices[4],vertices[2]),\n//   //   new Edge(vertices[5],vertices[1]),\n//   //   new Edge(vertices[5],vertices[2]),\n//   //   new Edge(vertices[5],vertices[3])\n//   // ]\n//\n//   edges.forEach((edge) => {\n//     edge.render(ctx);\n//   })\n//\n//   vertices.forEach((vertex) => {\n//     vertex.render(ctx);\n//   })\n//\n//   // v1.render(ctx);\n//   // v2.render(ctx);\n//   // v3.render(ctx);\n//   // v4.render(ctx);\n//   // v5.render(ctx);\n//   // v6.render(ctx);\n//\n// });\n\n// document.addEventListener(\"DOMContentLoaded\", () => {\n//\n//   var svg = d3.select(\"svg\"),\n//       width = +svg.attr(\"width\"),\n//       height = +svg.attr(\"height\");\n//\n//\n//               var simulation = d3.forceSimulation()\n//                   .force(\"link\", d3.forceLink().id(function(d) { return d.id; }))\n//                   //.force(\"charge\", d3.forceManyBody().strength(-200))\n//               \t\t.force('charge', d3.forceManyBody()\n//                     .strength(-1000)\n//                   )\n//               // \t\t.force('collide', d3.forceCollide()\n//               //       .radius(d => 40)\n//               //       .iterations(2)\n//               //     )\n//                   .force(\"center\", d3.forceCenter(width / 2, height / 2));\n//               const graph = {\n//                 \"nodes\": [\n//                   {\"id\": \"1\", \"group\": 1},\n//                   {\"id\": \"2\", \"group\": 2},\n//                 ],\n//                 \"links\": [\n//                   {\"source\": \"1\", \"target\": \"2\", \"value\": 1},\n//                 ]\n//               }\n//\n//\n//               function run(graph) {\n//\n//                 graph.links.forEach(function(d){\n//               //     d.source = d.source_id;\n//               //     d.target = d.target_id;\n//                 });\n//                 var link = svg.append(\"g\")\n//                               .style(\"stroke\", \"#aaa\")\n//                               .selectAll(\"line\")\n//                               .data(graph.links)\n//                               .enter().append(\"line\");\n//                 var node = svg.append(\"g\")\n//                           .attr(\"class\", \"nodes\")\n//                 .selectAll(\"circle\")\n//                           .data(graph.nodes)\n//                 .enter().append(\"circle\")\n//                         .attr(\"r\", 2)\n//\n//\n//                 var label = svg.append(\"g\")\n//                     .attr(\"class\", \"labels\")\n//                     .selectAll(\"text\")\n//                     .data(graph.nodes)\n//                     .enter().append(\"text\")\n//                       .attr(\"class\", \"label\")\n//                       .text(function(d) { return d.id; });\n//                 simulation\n//                     .nodes(graph.nodes)\n//                     .on(\"tick\", ticked);\n//                 simulation.force(\"link\")\n//                     .links(graph.links);\n//                 function ticked() {\n//                   link\n//                       .attr(\"x1\", function(d) { return d.source.x; })\n//                       .attr(\"y1\", function(d) { return d.source.y; })\n//                       .attr(\"x2\", function(d) { return d.target.x; })\n//                       .attr(\"y2\", function(d) { return d.target.y; });\n//                   node\n//                        .attr(\"r\", 16)\n//                        .style(\"fill\", \"#efefef\")\n//                        .style(\"stroke\", \"#424242\")\n//                        .style(\"stroke-width\", \"1px\")\n//                        .attr(\"cx\", function (d) { return d.x+5; })\n//                        .attr(\"cy\", function(d) { return d.y-3; });\n//                 }\n//               }\n//\n//\n//               run(graph)\n//\n//\n// });\n\n\nconst draw = require(\"./test3.js\");\nimport Mine from \"./mineTest.js\";\nimport Graph from \"./graph.js\";\nimport Graph2 from \"./graph2.js\";\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  // let graph2 = new Graph2();\n  // graph2.renderGraph();\n  // draw();\n  let mine = new Mine();\n  // mine.drawMine();\n  // let graph = new Graph();\n  // draw2();\n});\n","class Solver {\n  constructor(stepping, playback, count, matrix, parent, max_flow, svgGraph, mineSvg, mine){\n    // debugger\n    this.stepping = stepping;\n    this.playback = playback;\n    this.count = count;\n    this.matrix = matrix;\n    this.parent = parent;\n    this.max_flow = max_flow;\n    this.svgGraph = svgGraph;\n    this.infCapacity = 1000000;\n    this.setup();\n    this.animationInterval = 300;\n    this.mineSvg = mineSvg;\n    this.mine = mine;\n    this.solution;\n    this.colorMap = {\"#8B4513\": \"rust\", \"#FFD700\": \"gold\", \"#c8c8c8\": \"silver\", \"#bdad9c\": \"stone\"};\n  }\n\n  setup(){\n    // this.svgGraph.append(\"rect\")\n    // .attr(\"id\",\"step\")\n    // .attr(\"x\", 10)\n    // .attr(\"y\", 10)\n    // .attr(\"width\", 50)\n    // .attr(\"height\", 50)\n    // .attr(\"fill\", \"orange\")\n    //\n    // this.svgGraph.append(\"rect\")\n    // .attr(\"id\",\"play\")\n    // .attr(\"x\", 70)\n    // .attr(\"y\", 10)\n    // .attr(\"width\", 50)\n    // .attr(\"height\", 50)\n    // .attr(\"fill\", \"green\")\n    //\n    // this.svgGraph.append(\"rect\")\n    // .attr(\"id\",\"pause\")\n    // .attr(\"x\", 130)\n    // .attr(\"y\", 10)\n    // .attr(\"width\", 50)\n    // .attr(\"height\", 50)\n    // .attr(\"fill\", \"red\")\n    //\n    // this.svgGraph.append(\"rect\")\n    // .attr(\"id\",\"mine\")\n    // .attr(\"x\", 190)\n    // .attr(\"y\", 10)\n    // .attr(\"width\", 50)\n    // .attr(\"height\", 50)\n    // .attr(\"fill\", \"white\")\n\n    this.addListeners();\n  }\n\n  addListeners(){\n    // let playButton = document.getElementById(\"play\");\n    // playButton.addEventListener(\"click\", e => {\n    //   if (!this.stepping) {\n    //     // this.solver.step();\n    //     this.step();\n    //   }\n    //   this.playback = true;\n    // })\n    //\n    // let stepButton = document.getElementById(\"step\");\n    // stepButton.addEventListener(\"click\", e => {\n    //   this.step();\n    // })\n    //\n    // let pauseButton = document.getElementById(\"pause\");\n    // pauseButton.addEventListener(\"click\", e => {\n    //   // this.solver.playback = false;\n    //   this.playback = false;\n    // })\n    //\n    // let mineButton = document.getElementById(\"mine\");\n    // mineButton.addEventListener(\"click\", e => {\n    //   // this.solver.playback = false;\n    //   this.mineIt();\n    // })\n\n    document.getElementById(\"step-animation\").onclick = () => this.step();\n    document.getElementById(\"play-animation\").onclick = () => {\n      debugger\n      if (!this.stepping) {\n        // this.solver.step();\n        this.step();\n      }\n      this.playback = true;\n    }\n    document.getElementById(\"stop-animation\").onclick = () => this.playback = false;\n    document.getElementById(\"mine-animation\").onclick = () => this.mineIt();\n\n  }\n\n  mineIt(){\n    this.mineSvg.selectAll(\"rect\")\n    .transition()\n    .duration(1000)\n    .style(\"stroke\", \"black\")\n    .attr(\"fill\", d => {\n      return `url(#${this.colorMap[d.color]})`\n    })\n\n    const solutionBlocks = this.solution.slice(1).reverse();\n    let count = 1;\n\n\n    solutionBlocks.forEach(block => {\n      setTimeout(()=>{\n        this.mineBlock(block);\n      }, this.animationInterval * (count/2))\n      count++;\n    })\n  }\n\n  mineBlock(block){\n    this.mineSvg.selectAll(\"rect\")\n    .filter(d => {\n      debugger\n      return this.findIndexFromRowCol(d.row,d.col) === block\n    })\n    .transition()\n    .duration(1000)\n    .style(\"stroke\",\"none\")\n    .attr(\"fill\",\"none\")\n\n    this.mineSvg.selectAll(\"text\")\n    .filter(d => {\n      debugger\n      return this.findIndexFromRowCol(d.row,d.col) === block\n    })\n    .transition()\n    .duration(1000)\n    .style(\"fill\",\"none\")\n\n\n  }\n\n  BFS(graph, s, t, parent){\n    // debugger\n    let visited = [];\n    for (let i = 0; i < 5; i++){\n      visited.push(false);\n    }\n\n    let queue = [];\n\n    queue.push(s);\n    visited[s] = true;\n    //\n    while (queue.length > 0) {\n      let currentVtx = queue.shift();\n\n      graph[currentVtx].forEach((val, i) => {\n        if (!visited[i] && val > 0){\n          queue.push(i);\n          visited[i] = true;\n          parent[i] = currentVtx;\n        }\n      })\n    }\n    return {pathToSink: visited[t], parent}\n  }\n\n  step(){\n    debugger\n    this.stepping = true;\n    this.count = 0;\n    let graph = this.matrix;\n    let source = 0;\n    let sink = this.findIndexFromRowCol(0,this.mine[0].length-1)+1;\n    let parent = this.parent;\n    if (this.BFS(graph, source, sink, parent).pathToSink){\n      let path_flow = 91;\n      let s = sink;\n      let path = [s];\n      while (s != source){\n        // debugger\n        path_flow = Math.min(path_flow, graph[parent[s]][s]);\n        s = parent[s];\n        path.unshift(s);\n      }\n      //\n      this.animatePath(path, this.count, \"search\");\n      this.max_flow = this.max_flow + path_flow;\n      //\n      this.count = this.count + (path.length - 1);\n\n      let t = sink;\n      let augmentingPath = [t];\n      while (t != source){\n        let u = parent[t];\n        graph[u][t] =  graph[u][t] - path_flow;\n        graph[t][u] = graph[t][u] + path_flow;\n        let z = graph[u][t];\n        this.animateAugment(u,t,this.count,graph);\n        this.count = this.count + 1;\n        //\n        // updateCapacities(u,t,this.count);\n        t = parent[t];\n        augmentingPath.push(t)\n      }\n      // animatePath(augmentingPath, this.count, \"augment\",graph)\n\n      // this.count = this.count + (path.length - 1);\n      //\n\n      this.resetBFSLinks(path, this.count);\n\n      this.count = this.count + 1;\n      setTimeout(() => {\n        this.stepping = false;\n        if (this.playback){\n          // debugger\n          this.count = this.count + 1;\n            this.step()\n        }\n        // else{\n        //   count = 0;\n        // }\n      }, this.count*this.animationInterval);\n    }else{\n      let solution = [0];\n      let queue = [0]\n      let solutionEdges = [];\n\n      //finds solution nodes\n      this.matrix[0].forEach((el,i) => {\n        if (el > 0){\n          solution.push(i);\n          queue.push(i);\n          solutionEdges.push([0,i]);\n        }\n      })\n      //\n      while (queue.length > 0){\n        let nextNode = queue.shift();\n        this.matrix[nextNode].forEach((el,i) => {\n          if (el > 0 && !solution.includes(i)){\n            solution.push(i);\n            queue.push(i);\n            solutionEdges.push([nextNode,i]);\n          }\n        })\n      }this.solution = solution;\n\n      this.highlightSolution(solution,0,solutionEdges);\n      // debugger\n    }\n    // debugger\n  }\n\n\n  EK(graph, source, sink){\n\n    while (this.BFS(graph, source, sink, parent).pathToSink) {\n      let path_flow = 91;\n      let s = sink;\n      let path = [s];\n      while (s != source){\n        path_flow = Math.min(path_flow, graph[parent[s]][s]);\n        s = parent[s];\n        path.unshift(s);\n      }\n      //\n      this.animatePath(path, this.count, \"search\");\n      max_flow = max_flow + path_flow;\n      //\n      this.count = this.count + (path.length - 1);\n\n      let t = sink;\n      let augmentingPath = [t];\n      while (t != source){\n        let u = parent[t];\n        graph[u][t] =  graph[u][t] - path_flow;\n        graph[t][u] = graph[t][u] + path_flow;\n        let z = graph[u][t];\n        this.animateAugment(u,t,this.count,graph);\n        this.count = this.count + 1;\n        //\n        // updateCapacities(u,t,count);\n        t = parent[t];\n        augmentingPath.push(t)\n      }\n      // animatePath(augmentingPath, count, \"augment\",graph)\n\n      // count = count + (path.length - 1);\n      //\n\n      this.resetBFSLinks(path, this.count);\n      this.count = this.count + 1;\n    }\n\n    let solution = [0];\n    let queue = [0]\n    let solutionEdges = [];\n\n    //finds solution nodes\n    graph[0].forEach((el,i) => {\n      if (el > 0){\n        solution.push(i);\n        queue.push(i);\n        solutionEdges.push([0,i]);\n      }\n    })\n    //\n    while (queue.length > 0){\n      let nextNode = queue.shift();\n      graph[nextNode].forEach((el,i) => {\n        if (el > 0 && !solution.includes(i)){\n          solution.push(i);\n          queue.push(i);\n          solutionEdges.push([nextNode,i]);\n        }\n      })\n    }\n    this.count = this.count + 1;\n\n\n    return {max_flow, solution, count:this.count, solutionEdges};\n  }\n\n  updateCapacities(source,target,count,graph){\n    //\n    setTimeout(() => {\n      //\n      this.svgGraph.selectAll(\"textPath\")\n      .filter(function(d){\n        //\n        return d.source.index === source && d.target.index === target;\n      })\n      .text((d) => {\n        //\n        let cap;\n        // debugger\n        if (d.capacity === this.infCapacity){\n          cap = `∞`\n        }\n        else{\n          cap = `${d.capacity}`\n        }\n        //\n        return `${d.capacity - graph[source][target]}:${cap}`\n      })\n    },this.animationInterval/2);\n  }\n\n  pathMatch(tmpArr, solutionArr){\n    let result = false;\n    solutionArr.forEach(arr => {\n      if (tmpArr[0] === arr[0] && tmpArr[1] === arr[1]){\n        result = true;\n      }\n    })\n    return result;\n  }\n\n  highlightSolution(solution, count, solutionEdges){\n    setTimeout(() => {\n      this.svgGraph.selectAll(\"circle\")\n      // .filter(function(d) {\n      //   //\n      //   return solution.includes(d.index);\n      // })\n      .transition()\n      .duration(1000)\n      .attr(\"fill\", function(d){\n        if (solution.includes(d.index)){\n          return \"white\"\n        }else{\n          return \"black\"\n        }\n      })\n\n      this.svgGraph.selectAll(\"text\")\n      // .filter(function(d) {\n      //   //\n      //   return solution.includes(d.index);\n      // })\n      .transition()\n      .duration(1000)\n      .style(\"fill\", function(d){\n        // return \"black\"\n        if (solution.includes(d.index)){\n          return \"black\"\n        }else{\n          return \"gray\"\n        }\n      });\n\n      this.mineSvg.selectAll(\"rect\")\n      .transition()\n      .duration(1000)\n      // .attr(\"fill\", (d) => {\n      //   if (solution.includes(this.findIndexFromRowCol(d.row,d.col))){\n      //     return \"white\"\n      //   }else{\n      //     return \"black\"\n      //   }\n      // })\n      .style(\"stroke\", (d) => {\n        if (d.border === \"red\"){\n          return \"red\"\n        }else{\n          if (solution.includes(this.findIndexFromRowCol(d.row,d.col))){\n            return \"black\"\n          }else{\n            return \"white\"\n          }\n        }\n      })\n      .attr(\"fill\", d => {\n        if (solution.includes(this.findIndexFromRowCol(d.row,d.col))){\n          return \"white\"\n        }else{\n          return \"black\"\n        }\n      })\n\n    },this.animationInterval*count)\n  }\n\n  animateAugment(source,target,count,graph){\n    // updateCapacities(source,target,count,graph);\n    setTimeout(() => {\n      this.svgGraph.selectAll(\".link\")\n      .filter((d)=>{\n\n        //\n        if (d.source.index === source && d.target.index === target){\n          //\n          this.updateCapacities(d.source.index, d.target.index,count,graph);\n          return true;\n        // return d.source.index === path[i+1] && d.target.index === path[i]\n        }\n      })\n      .transition()\n      .duration(this.animationInterval)\n      .style(\"stroke\", function(){\n          return \"#039ab5\"\n      })\n\n      this.mineSvg.selectAll(\"rect\")\n      .filter((d)=>{\n        if (this.findIndexFromRowCol(d.row,d.col) === target){\n          return true;\n        // return d.source.index === path[i+1] && d.target.index === path[i]\n        }\n      })\n      .transition()\n      .duration(this.animationInterval)\n      .attr(\"fill\", function(){\n          return \"#039ab5\"\n      })\n    }, this.animationInterval*count)\n  }\n\n  findIdFromIndex(index){\n    const second = index%4;\n    const first = (index-second)/4;\n    return `rect:${first}-${second}`\n  }\n\n  findIndexFromRowCol(row,col){\n    let minRow = this.mine[this.mine.length-1].length;\n    let height = this.mine.length;\n    let offset;\n    if (row === this.mine.length - 1){\n      offset = 0;\n    }else{\n      let n = height-2-row;\n      offset = (n*(n+1))/2;\n    }\n    return minRow*(height-1-row) + col + 1 + offset;\n  }\n\n  animatePath(path, count, type,graph) {\n    for (let i = 0; i < path.length - 1; i++){\n      // debugger\n      setTimeout(() => {\n        this.svgGraph.selectAll(\".link\")\n        .filter(function(d){\n          if (type === \"search\"){\n            return d.source.index === path[i] && d.target.index === path[i+1]\n          }else{\n            debugger\n            if (d.source.index === path[i+1] && d.target.index === path[i]){\n              //\n              this.updateCapacities(d.source.index, d.target.index,count,graph);\n              return true;\n            }\n            // return d.source.index === path[i+1] && d.target.index === path[i]\n          }\n        })\n        .transition()\n        .duration(this.animationInterval)\n        .style(\"stroke\", function(){\n          if (type === \"search\"){\n            return \"red\"\n          }else if (type === \"augment\"){\n            return \"#039ab5\"\n          }\n        })\n        .style(\"stroke-width\", d => {\n          return (d.capacity > 5 ? 4 : 8);\n        })\n\n        this.mineSvg.selectAll(\"rect\").filter((d) => {\n          if (type === \"search\"){\n            if (this.findIndexFromRowCol(d.row,d.col) === path[i+1]){\n              debugger\n              return true;\n            }\n          }else{\n            debugger\n            if (this.findIndexFromRowCol(d.row,d.col) === path[i]){\n              debugger\n              return true;\n            }\n          }\n        })\n        .transition()\n        .duration(this.animationInterval)\n        .attr(\"fill\", function(){\n          if (type === \"search\"){\n            return \"red\"\n          }else if (type === \"augment\"){\n            return \"#039ab5\"\n          }\n        })\n      }, this.animationInterval*count)\n      count = count + 1\n    }\n  }\n\n  resetBFSLinks(path,count){\n    for (let i = 0; i < path.length - 1; i++){\n      setTimeout(() => {\n        this.svgGraph.selectAll(\".link\")\n        .filter(function(d){\n          //\n          return d.source.index === path[i] && d.target.index === path[i+1]\n        })\n        .transition()\n        .duration(this.animationInterval)\n        .style(\"stroke\", (d)=>{\n          debugger\n          if (d.capacity === this.infCapacity){\n            return \"#444444\"\n          }else if (d.target.label === \"t\"){\n            if (d.capacity === 3){\n              return `url(#rust)`;\n            }else{\n              return `url(#stone)`;\n            }\n          }else if ( d.source.label === \"s\"){\n            if (d.capacity === 5){\n              return `url(#gold)`;\n            }else{\n              return `url(#silver)`;\n            }\n          }\n        })\n        .style(\"stroke-width\", d => {\n          return (d.capacity > 5 ? 4 : 8);\n        })\n\n        this.mineSvg.selectAll(\"rect\")\n        .filter((d) => {\n          debugger\n          return this.findIndexFromRowCol(d.row,d.col) === path[i+1]\n        })\n        .transition()\n        .duration(this.animationInterval)\n        .attr(\"fill\", (d)=>{\n          debugger\n          return `url(#${this.colorMap[d.color]})`;\n        })\n      }, this.animationInterval*count)\n    }\n  }\n}\n\nexport default Solver;\n","// const EK = require(\"./ek-animated.js\");\n\n\nconst draw3 = function(){\n  let width = 900,\n      height = 900;\n\n  animationInterval = 500;\n\n  let matrix = [\n    [0,5,2,2,0,0,0,0,0,0],\n    [0,0,0,0,25,25,25,0,0,0],\n    [0,0,0,0,0,25,25,25,0,0],\n    [0,0,0,0,0,0,25,25,25,0],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,0]\n  ]\n\n  let nodes = [\n    {label: \"s\", index: 0, profit: null, row: null, fixed: true, x: width/2, y: height-100},\n    {label: \"a\", index: 1, profit: matrix[0][1], row: 1, fixed: true, x: width/2-150, y: height - 325},\n    {label: \"b\", index: 2, profit: matrix[0][2], row: 1},\n    {label: \"c\", index: 3, profit: matrix[0][3], row: 1, fixed: true, x: width/2+150, y: height - 325},\n    {label: \"d\", index: 4, profit: matrix[4][9]*-1, row: 0, fixed: true, x: width/2 - 200, y: 325},\n    {label: \"e\", index: 5, profit: matrix[5][9]*-1, row: 0},\n    {label: \"f\", index: 6, profit: matrix[6][9]*-1, row: 0},\n    {label: \"g\", index: 7, profit: matrix[7][9]*-1, row: 0},\n    {label: \"h\", index: 8, profit: matrix[8][9]*-1, row: 0, fixed: true, x: width/2 + 200, y: 325},\n    {label: \"t\", index: 9, profit: null, row: null, fixed: true, x: width/2, y: 100}\n  ]\n\n  let links = [\n  ]\n\n  //defines the u -> v edges, i.e. must complete project v before starting project u\n  let restrictions = [\n    {source: 1, target: 4},\n    {source: 1, target: 5},\n    {source: 1, target: 6},\n    {source: 2, target: 5},\n    {source: 2, target: 6},\n    {source: 2, target: 7},\n    {source: 3, target: 6},\n    {source: 3, target: 7},\n    {source: 3, target: 8},\n  ]\n\n  //effectively the sum of all other capacities + 1 (commonly C + 1)\n  infCapacity = 1000000;\n\n  //computes C + 1\n  const simulateInfCapacity = () => {\n    nodes.forEach(node => {\n      if (node.profit !== null){\n        if (node.profit > 0){\n          infCapacity = infCapacity + node.profit\n        }else{\n          infCapacity = infCapacity - node.profit\n        }\n      }\n    })\n    infCapacity = infCapacity + 1;\n  }\n\n  let linkIdIdx = 0;\n  //creates links with finite capacities\n  const setFiniteLinks = () => {\n    nodes.forEach((node,i) => {\n      //\n      if (node.label !== \"s\" && node.label !== \"t\"){\n        if (node.profit > 0){\n          links.push({source: 0, target: i, res: 0, capacity: node.profit})\n        }else{\n          links.push({source: i, target: (nodes.length-1), capacity: (-1 * node.profit), res: 0, id: linkIdIdx})\n        }\n      }\n      linkIdIdx = linkIdIdx + 1;\n    })\n  }\n  //creates links with infinite capacities\n  const setInfiniteLinks = () => {\n    restrictions.forEach(restriction => {\n      links.push({source: restriction.source, target: restriction.target, res: 0, capacity: infCapacity, id: linkIdIdx})\n      linkIdIdx = linkIdIdx + 1;\n    })\n  }\n  // simulateInfCapacity();\n  setInfiniteLinks();\n  setFiniteLinks();\n  //\n\n  //create object for manipulation\n  let svg = d3.select('body').append('svg')\n      .attr('width', width)\n      .attr('height', height);\n\n  //\n  //apply force conditions\n\n  let force = d3.layout.force()\n      .size([width, height])\n      .nodes(d3.values(nodes))\n      .links(links)\n      .on(\"tick\", () => {\n        debugger\n        node.attr('cx', function(d) {\n          debugger\n            return d.x;\n          })\n          .attr('cy', function(d) { return d.y; })\n          .attr(\"transform\", function(d) { return `translate(${d.x},${d.y})`; });\n\n    debugger\n    link.attr('x1', function(d) { return d.source.x; })\n        .attr('y1', function(d) { return d.source.y; })\n        .attr('x2', function(d) { return d.target.x; })\n        .attr('y2', function(d) { return d.target.y; });\n\n\n        edgepaths.attr('d', function(d) {\n          let path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;\n          return path\n        });\n\n        // edgelabels.attr('transform',function(d,i){\n        //     if (d.target.x<d.source.x){\n        //         bbox = this.getBBox();\n        //         rx = bbox.x+bbox.width/2;\n        //         ry = bbox.y+bbox.height/2;\n        //         return 'rotate(180 '+rx+' '+ry+')';\n        //         }\n        //     else {\n        //         return 'rotate(0)';\n        //         }\n        // });\n\n        edgelabels.attr(\"transform\", function(d,i){\n          if (d.target.x < d.source.x){\n            bbox = this.getBBox();\n            rx = bbox.x + bbox.width/2;\n            ry = bbox.y + bbox.height/2;\n            return `rotate(180 ${rx} ${ry})`;\n          }\n          else{\n            return \"rotate(0)\";\n          }\n        })\n      })\n      // .linkDistance(100)\n      .gravity(0.1)\n      .charge(-1200)\n      .linkDistance(120)\n      .linkStrength(0.1)\n      .start();\n\n      // link.append(\"linkLabel\")\n      //   .append(\"text\")\n      //   .attr(\"class\",\"linkLabel\")\n      //   .attr(\"x\",\"50\")\n      //   .attr(\"y\",\"-20\")\n      //   .attr(\"text-anchor\",\"start\")\n      //   .style(\"fill\",\"#000\")\n      //   .attr(\"xlink:href\",function(d,i){\n      //\n      //     return `#linkId_${i}`;})\n      //   .text(function(d) {\n      //     return d.id;\n      //   })\n\n  //create links\n  let link = svg.append(\"g\").selectAll('.link')\n      .data(links)\n      .enter().append('line')\n      .attr(\"class\", \"link\")\n      .attr('id', function(d) {\n        return `link_${d.id}`})\n      .style(\"stroke\", function(d){\n        if (d.capacity === infCapacity){\n          return \"#000\"\n        }else if (d.target.label === \"t\"){\n          return \"#632f12\"\n        }else if ( d.source.label === \"s\"){\n          return \"#fff\"\n        }\n      })\n      // .attr(\"marker-end\",\"url(#arrowhead)\")\n      .style(\"stroke-width\", \"4\")\n\n      //create nodes\n      let node = svg.selectAll(\".node\")\n      .data(nodes)\n      .enter().append(\"g\")\n      .attr('class', 'node')\n      // .attr(\"transform\",transform);\n      .call(force.drag);\n\n      //add circle to visualize nodes\n      node.append(\"circle\")\n      .attr('r', 12)\n      .attr(\"fill\", function(d) {\n        if (d.label === \"s\"){\n          return \"#ce9308\"\n        }else if (d.label === \"t\"){\n          return \"#969696\"\n        }else if (d.profit !== null && d.profit > 0){\n          return \"#31703d\"\n        }else if (d.profit !== null && d.profit <= 0){\n          return \"#961919\"\n        }\n      })\n      .style(\"stroke\", \"#fff\")\n      .style(\"stroke-weight\", \"3\")\n\n      //add node labels\n      node.append(\"text\")\n      .attr(\"class\",\"nodeLabel\")\n      .attr(\"dx\", \"-.2em\")\n      .attr(\"dy\", \".35em\")\n      .style(\"fill\", \"white\")\n      .text(function(d) {return d.label})\n\n  let edgepaths = svg.selectAll(\".edgepath\")\n      .data(links)\n      .enter()\n      .append('path')\n      .attr({'d': function(d) {\n        //\n        return 'M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y},\n             'class':'edgepath',\n             'fill-opacity':0,\n             'stroke-opacity':0,\n             'fill':'blue',\n             'stroke':'red',\n             'id':function(d,i) {return `edgepath:${d.source.index}-${d.target.index}`}})\n      .style(\"pointer-events\", \"none\");\n  //\n      var edgelabels = svg.selectAll(\".edgelabel\")\n          .data(links)\n          .enter()\n          .append('text')\n          .style(\"pointer-events\", \"none\")\n          .attr({'class':'edgelabel',\n                 'id':function(d,i){return 'edgelabel'+i},\n                 'dx':80,\n                 'dy':-5,\n                 'font-size':20,\n                 'fill':'#aaa'});\n  //\n  //\n       edgelabels.append('textPath')\n           .attr('xlink:href',function(d,i) {\n             //\n              return `#edgepath:${d.source.index}-${d.target.index}`})\n             // return '#edgepath'+i})\n           .style(\"pointer-events\", \"none\")\n           .text(function(d){\n             // `${d.capacity}`\n             let cap;\n             if (d.capacity === infCapacity){\n               cap = `∞`\n             }\n             else{\n               cap = `${d.capacity}`\n             }\n             return `${d.res}:${cap}`});\n\n       svg.append(\"rect\")\n       .attr(\"id\",\"step\")\n       .attr(\"x\", 10)\n       .attr(\"y\", 10)\n       .attr(\"width\", 50)\n       .attr(\"height\", 50)\n       .attr(\"fill\", \"white\")\n\n       svg.append(\"rect\")\n       .attr(\"id\",\"play\")\n       .attr(\"x\", 70)\n       .attr(\"y\", 10)\n       .attr(\"width\", 50)\n       .attr(\"height\", 50)\n       .attr(\"fill\", \"orange\")\n\n       svg.append(\"rect\")\n       .attr(\"id\",\"pause\")\n       .attr(\"x\", 130)\n       .attr(\"y\", 10)\n       .attr(\"width\", 50)\n       .attr(\"height\", 50)\n       .attr(\"fill\", \"red\")\n\n    // let link = svg.selectAll(\".link\")\n    //   .data(force.links())\n    //   .enter().append(\"g\")\n    //   .attr(\"class\",\"link\")\n    //\n    //\n    // link.append(\"line\")\n    // .attr('id', function(d) {\n    //   return `link_${d.id}`})\n    // .style(\"stroke\", function(d){\n    //   if (d.capacity === infCapacity){\n    //     return \"#000\"\n    //   }else if (d.target.label === \"t\"){\n    //     return \"#632f12\"\n    //   }else if ( d.source.label === \"s\"){\n    //     return \"#fff\"\n    //   }\n    // })\n    // .style(\"stroke-width\", \"5\");\n\n  // function tick(e) {\n  //     node.attr('cx', function(d) {\n  //\n  //         return d.x;\n  //       })\n  //       .attr('cy', function(d) { return d.y; })\n  //       .attr(\"transform\", function(d) { return `translate(${d.x},${d.y})`; });\n  //\n  //     link.attr('x1', function(d) { return d.source.x; })\n  //         .attr('y1', function(d) { return d.source.y; })\n  //         .attr('x2', function(d) { return d.target.x; })\n  //         .attr('y2', function(d) { return d.target.y; });\n  //\n  //\n  //     edgepaths.attr('d', function(d) {\n  //       let path='M '+d.source.x+' '+d.source.y+' L '+ d.target.x +' '+d.target.y;\n  //       return path\n  //     });\n  //\n  //     // edgelabels.attr('transform',function(d,i){\n  //     //     if (d.target.x<d.source.x){\n  //     //         bbox = this.getBBox();\n  //     //         rx = bbox.x+bbox.width/2;\n  //     //         ry = bbox.y+bbox.height/2;\n  //     //         return 'rotate(180 '+rx+' '+ry+')';\n  //     //         }\n  //     //     else {\n  //     //         return 'rotate(0)';\n  //     //         }\n  //     // });\n  //\n  //     edgelabels.attr(\"transform\", function(d,i){\n  //       if (d.target.x < d.source.x){\n  //         bbox = this.getBBox();\n  //         rx = bbox.x + bbox.width/2;\n  //         ry = bbox.y + bbox.height/2;\n  //         return `rotate(180 ${rx} ${ry})`;\n  //       }\n  //       else{\n  //         return \"rotate(0)\";\n  //       }\n  //     })\n  // }\n\n\n  const BFS = (graph, s, t, parent) => {\n    let visited = [];\n    for (let i = 0; i < 5; i++){\n      visited.push(false);\n    }\n\n    let queue = [];\n\n    queue.push(s);\n    visited[s] = true;\n    //\n    while (queue.length > 0) {\n      let currentVtx = queue.shift();\n\n      graph[currentVtx].forEach((val, i) => {\n        if (!visited[i] && val > 0){\n          queue.push(i);\n          visited[i] = true;\n          parent[i] = currentVtx;\n        }\n      })\n    }\n    return {pathToSink: visited[t], parent}\n  }\n\n  let parent = [];\n\n  for (let i = 0; i < matrix.length; i++){\n    parent.push(-1);\n  }\n\n  let count = 0;\n  let max_flow = 0;\n  let cont = true;\n  let playback = false;\n  let stepping = false;\n\n  const step = () => {\n    stepping = true;\n    debugger\n    count = 0;\n    graph = matrix;\n    source = 0;\n    sink = 9;\n    if (BFS(graph, source, sink, parent).pathToSink){\n      let path_flow = 91;\n      let s = sink;\n      let path = [s];\n      while (s != source){\n        path_flow = Math.min(path_flow, graph[parent[s]][s]);\n        s = parent[s];\n        path.unshift(s);\n      }\n      //\n      animatePath(path, count, \"search\");\n      max_flow = max_flow + path_flow;\n      //\n      count = count + (path.length - 1);\n\n      let t = sink;\n      let augmentingPath = [t];\n      while (t != source){\n        let u = parent[t];\n        graph[u][t] =  graph[u][t] - path_flow;\n        graph[t][u] = graph[t][u] + path_flow;\n        let z = graph[u][t];\n        animateAugment(u,t,count,graph);\n        count = count + 1;\n        //\n        // updateCapacities(u,t,count);\n        t = parent[t];\n        augmentingPath.push(t)\n      }\n      // animatePath(augmentingPath, count, \"augment\",graph)\n\n      // count = count + (path.length - 1);\n      //\n\n      resetBFSLinks(path, count);\n\n      count = count + 1;\n      setTimeout(() => {\n        stepping = false;\n        if (playback){\n          debugger\n          count = count + 1;\n            step()\n        }\n        // else{\n        //   count = 0;\n        // }\n      }, count*animationInterval);\n    }\n  }\n\n\n  const EK = (graph, source, sink) => {\n\n    while (BFS(graph, source, sink, parent).pathToSink) {\n      let path_flow = 91;\n      let s = sink;\n      let path = [s];\n      while (s != source){\n        path_flow = Math.min(path_flow, graph[parent[s]][s]);\n        s = parent[s];\n        path.unshift(s);\n      }\n      //\n      animatePath(path, count, \"search\");\n      max_flow = max_flow + path_flow;\n      //\n      count = count + (path.length - 1);\n\n      let t = sink;\n      let augmentingPath = [t];\n      while (t != source){\n        let u = parent[t];\n        graph[u][t] =  graph[u][t] - path_flow;\n        graph[t][u] = graph[t][u] + path_flow;\n        let z = graph[u][t];\n        animateAugment(u,t,count,graph);\n        count = count + 1;\n        //\n        // updateCapacities(u,t,count);\n        t = parent[t];\n        augmentingPath.push(t)\n      }\n      // animatePath(augmentingPath, count, \"augment\",graph)\n\n      // count = count + (path.length - 1);\n      //\n\n      resetBFSLinks(path, count);\n      count = count + 1;\n    }\n\n    let solution = [0];\n    let queue = [0]\n    let solutionEdges = [];\n\n    //finds solution nodes\n    graph[0].forEach((el,i) => {\n      if (el > 0){\n        solution.push(i);\n        queue.push(i);\n        solutionEdges.push([0,i]);\n      }\n    })\n    //\n    while (queue.length > 0){\n      let nextNode = queue.shift();\n      graph[nextNode].forEach((el,i) => {\n        if (el > 0 && !solution.includes(i)){\n          solution.push(i);\n          queue.push(i);\n          solutionEdges.push([nextNode,i]);\n        }\n      })\n    }\n    count = count + 1;\n\n\n    return {max_flow, solution,count,solutionEdges};\n  }\n\n  function addListeners(){\n    let playButton = document.getElementById(\"play\");\n    playButton.addEventListener(\"click\", e => {\n      if (!stepping) {\n        step();\n      }\n      playback = true;\n    })\n\n    let stepButton = document.getElementById(\"step\");\n    stepButton.addEventListener(\"click\", e => {\n      step();\n    })\n\n    let pauseButton = document.getElementById(\"pause\");\n    pauseButton.addEventListener(\"click\", e => {\n      playback = false;\n    })\n  }\n\n  addListeners();\n  // step();\n\n  // let node.enter().append(\"text\")\n\n\n\n  ///USEFUL STUFF RIGHT HERE\n  // setTimeout(function(){\n  //   svg.selectAll(\"textPath\")\n  //   .filter(function(d){\n  //     //\n  //     return d.source.index === 0 && d.target.index === 1;\n  //   })\n  //   .text(\"4\")\n  // },1000);\n  //\n\n\n  let result;\n  // highlightSolution(result.solution, result.count, result.solutionEdges);\n\n\n  function updateCapacities(source,target,count,graph){\n    //\n    setTimeout(function(){\n      //\n      svg.selectAll(\"textPath\")\n      .filter(function(d){\n        //\n        return d.source.index === source && d.target.index === target;\n      })\n      .text(function(d){\n        //\n        let cap;\n        if (d.capacity === infCapacity){\n          cap = `∞`\n        }\n        else{\n          cap = `${d.capacity}`\n        }\n        //\n        return `${d.capacity - graph[source][target]}:${cap}`\n      }\n    )\n    },animationInterval/2);\n  }\n\n  function pathMatch(tmpArr, solutionArr){\n    let result = false;\n    solutionArr.forEach(arr => {\n      if (tmpArr[0] === arr[0] && tmpArr[1] === arr[1]){\n        result = true;\n      }\n    })\n    return result;\n  }\n\n  function highlightSolution(solution, count, solutionEdges){\n    setTimeout(function(){\n      svg.selectAll(\"circle\")\n      // .filter(function(d) {\n      //   //\n      //   return solution.includes(d.index);\n      // })\n      .transition()\n      .duration(1000)\n      .attr(\"fill\", function(d){\n        if (solution.includes(d.index)){\n          return \"white\"\n        }else{\n          return \"black\"\n        }\n      })\n\n      svg.selectAll(\"text\")\n      // .filter(function(d) {\n      //   //\n      //   return solution.includes(d.index);\n      // })\n      .transition()\n      .duration(1000)\n      .style(\"fill\", function(d){\n        // return \"black\"\n        if (solution.includes(d.index)){\n          return \"black\"\n        }else{\n          return \"gray\"\n        }\n      });\n\n      // svg.selectAll(\".link\").filter(function(d) {\n      //   let tmp = [d.source.index,d.target.index];\n      //   //\n      //   pathMatch(tmp,solutionEdges)\n      //   return pathMatch(tmp,solutionEdges);\n      // })\n      // .transition()\n      // .duration(1000)\n      // .style(\"stroke\", \"red\")\n    },animationInterval*count)\n  }\n\n  function animateAugment(source,target,count,graph){\n    // updateCapacities(source,target,count,graph);\n    setTimeout(function(){\n      svg.selectAll(\".link\")\n      .filter(function(d){\n\n        //\n        if (d.source.index === source && d.target.index === target){\n          //\n          updateCapacities(d.source.index, d.target.index,count,graph);\n          return true;\n        // return d.source.index === path[i+1] && d.target.index === path[i]\n        }\n      })\n      .transition()\n      .duration(animationInterval)\n      .style(\"stroke\", function(){\n          return \"#039ab5\"\n      })\n    }, animationInterval*count)\n  }\n\n  function animatePath(path, count, type,graph) {\n    for (let i = 0; i < path.length - 1; i++){\n      setTimeout(function(){\n        svg.selectAll(\".link\")\n        .filter(function(d){\n          if (type === \"search\"){\n            return d.source.index === path[i] && d.target.index === path[i+1]\n          }else{\n            if (d.source.index === path[i+1] && d.target.index === path[i]){\n              //\n              updateCapacities(d.source.index, d.target.index,count,graph);\n              return true;\n            }\n            // return d.source.index === path[i+1] && d.target.index === path[i]\n          }\n        })\n        .transition()\n        .duration(animationInterval)\n        .style(\"stroke\", function(){\n          if (type === \"search\"){\n            return \"red\"\n          }else if (type === \"augment\"){\n            return \"#039ab5\"\n          }\n        })\n      }, animationInterval*count)\n      count = count + 1\n      //\n    }\n\n  }\n\n  function resetBFSLinks(path,count){\n    for (let i = 0; i < path.length - 1; i++){\n      setTimeout(function(){\n        svg.selectAll(\".link\")\n        .filter(function(d){\n          //\n          return d.source.index === path[i] && d.target.index === path[i+1]\n        })\n        .transition()\n        .duration(animationInterval)\n        .style(\"stroke\", function(d){\n          if (d.capacity === infCapacity){\n            return \"#000\"\n          }else if (d.target.label === \"t\"){\n            return \"#632f12\"\n          }else if ( d.source.label === \"s\"){\n            return \"#fff\"\n          }\n        })\n      }, animationInterval*count)\n    }\n  }\n\n}\n\nmodule.exports = draw3;\n"],"sourceRoot":""}