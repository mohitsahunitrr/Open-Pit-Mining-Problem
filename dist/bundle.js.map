{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./miner.js","webpack:///./test3.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,aAAa,EAAE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,sBAAsB,sBAAsB;AAC5C;AACA;AACA,sBAAsB,yCAAyC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,mBAAmB,EAAE;AACvE,kDAAkD,mBAAmB,EAAE;AACvE,kDAAkD,mBAAmB,EAAE;AACvE,kDAAkD,mBAAmB,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAc,EAAE;AACpE,mDAAmD,cAAc,EAAE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ,aAAa,mBAAO,CAAC,8BAAY;AACjC;AACA;AACA,CAAC;;;;;;;;;;;;ACzLD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK,sFAAsF;AAC3F,KAAK,qFAAqF;AAC1F,KAAK,wCAAwC;AAC7C,KAAK,sFAAsF;AAC3F,KAAK,gFAAgF;AACrF,KAAK,yCAAyC;AAC9C,KAAK,yCAAyC;AAC9C,KAAK,yCAAyC;AAC9C,KAAK,gFAAgF;AACrF,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B,KAAK,qBAAqB;AAC1B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4CAA4C;AAClE,SAAS;AACT,sBAAsB,0EAA0E;AAChG;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,8EAA8E;AAChG,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB,eAAe;;AAEpC;AACA;AACA;AACA,qBAAqB,kBAAkB;;AAEvC;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,YAAY,EAAE;AAC/C,wCAAwC,qBAAqB,IAAI,GAAG,IAAI,GAAG,EAAE;;AAE7E,mCAAmC,mBAAmB,EAAE;AACxD,mCAAmC,mBAAmB,EAAE;AACxD,mCAAmC,mBAAmB,EAAE;AACxD,mCAAmC,mBAAmB,EAAE;AACxD;;;AAGA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;;;;;;;;;;;;;;AAcN;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,YAAY;AACZ;;AAEA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,YAAY;AACZ;;;AAGA;AACA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;;AAGA","file":"./bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./miner.js\");\n","// // const Vertex = require(\"./vertex.js\");\n// const Vertex = require(\"./vertex.js\");\n//\n// // import Vertex from \"./vertex.js\";\n//\n// document.addEventListener(\"DOMContentLoaded\", () => {\n//   const canvas = document.getElementById(\"canvas\");\n//   const ctx = canvas.getContext(\"2d\");\n//\n//   // const Vertex = function(x,y,r){\n//   //   this.x = x,\n//   //   this.y = y,\n//   //   this.r = r\n//   // }\n//   //\n//   // Vertex.prototype.render = function(ctx){\n//   //   ctx.beginPath();\n//   //   ctx.arc(this.x,this.y,this.r,0,2*Math.PI);\n//   //   ctx.fillStyle = \"red\";\n//   //   ctx.fill();\n//   // }\n//\n//   const Edge = function(v1, v2){\n//     this.v1 = v1;\n//     this.v2 = v2;\n//   }\n//\n//   Edge.prototype.render = function(ctx){\n//     ctx.beginPath();\n//     ctx.moveTo(this.v1.x,this.v1.y);\n//     ctx.lineTo(this.v2.x,this.v2.y);\n//     ctx.lineWidth = 10;\n//     ctx.strokeStyle = \"purple\";\n//     ctx.stroke();\n//   }\n//\n//   const EdgeArrow = function(v1,v2){\n//\n//   }\n//\n//   const matrix = [\n//     [0,0,1,1,1,0],\n//     [0,0,0,1,1,1],\n//     [0,0,0,0,0,0],\n//     [0,0,0,0,0,0],\n//     [0,0,0,0,0,0],\n//     [0,0,0,0,0,0]\n//   ]\n//\n//   const vertices = [\n//     new Vertex(300,300,20),\n//     new Vertex(500,300,20),\n//\n//     new Vertex(100,100,20),\n//     new Vertex(300,100,20),\n//     new Vertex(500,100,20),\n//     new Vertex(700,100,20)\n//   ]\n//   const edges = [];\n//\n//   const generateEdgesFromMatrix = function(matrix){\n//     matrix.forEach((row, i) => {\n//       row.forEach((el, j) => {\n//         if (el > 0){\n//           edges.push(new Edge(vertices[i],vertices[j]));\n//         }\n//       })\n//     })\n//   }\n//\n//   generateEdgesFromMatrix(matrix);\n//\n//\n//   // const edges = [\n//   //   new Edge(vertices[4],vertices[0]),\n//   //   new Edge(vertices[4],vertices[1]),\n//   //   new Edge(vertices[4],vertices[2]),\n//   //   new Edge(vertices[5],vertices[1]),\n//   //   new Edge(vertices[5],vertices[2]),\n//   //   new Edge(vertices[5],vertices[3])\n//   // ]\n//\n//   edges.forEach((edge) => {\n//     edge.render(ctx);\n//   })\n//\n//   vertices.forEach((vertex) => {\n//     vertex.render(ctx);\n//   })\n//\n//   // v1.render(ctx);\n//   // v2.render(ctx);\n//   // v3.render(ctx);\n//   // v4.render(ctx);\n//   // v5.render(ctx);\n//   // v6.render(ctx);\n//\n// });\n\n// document.addEventListener(\"DOMContentLoaded\", () => {\n//\n//   var svg = d3.select(\"svg\"),\n//       width = +svg.attr(\"width\"),\n//       height = +svg.attr(\"height\");\n//\n//\n//               var simulation = d3.forceSimulation()\n//                   .force(\"link\", d3.forceLink().id(function(d) { return d.id; }))\n//                   //.force(\"charge\", d3.forceManyBody().strength(-200))\n//               \t\t.force('charge', d3.forceManyBody()\n//                     .strength(-1000)\n//                   )\n//               // \t\t.force('collide', d3.forceCollide()\n//               //       .radius(d => 40)\n//               //       .iterations(2)\n//               //     )\n//                   .force(\"center\", d3.forceCenter(width / 2, height / 2));\n//               const graph = {\n//                 \"nodes\": [\n//                   {\"id\": \"1\", \"group\": 1},\n//                   {\"id\": \"2\", \"group\": 2},\n//                 ],\n//                 \"links\": [\n//                   {\"source\": \"1\", \"target\": \"2\", \"value\": 1},\n//                 ]\n//               }\n//\n//\n//               function run(graph) {\n//\n//                 graph.links.forEach(function(d){\n//               //     d.source = d.source_id;\n//               //     d.target = d.target_id;\n//                 });\n//                 var link = svg.append(\"g\")\n//                               .style(\"stroke\", \"#aaa\")\n//                               .selectAll(\"line\")\n//                               .data(graph.links)\n//                               .enter().append(\"line\");\n//                 var node = svg.append(\"g\")\n//                           .attr(\"class\", \"nodes\")\n//                 .selectAll(\"circle\")\n//                           .data(graph.nodes)\n//                 .enter().append(\"circle\")\n//                         .attr(\"r\", 2)\n//\n//\n//                 var label = svg.append(\"g\")\n//                     .attr(\"class\", \"labels\")\n//                     .selectAll(\"text\")\n//                     .data(graph.nodes)\n//                     .enter().append(\"text\")\n//                       .attr(\"class\", \"label\")\n//                       .text(function(d) { return d.id; });\n//                 simulation\n//                     .nodes(graph.nodes)\n//                     .on(\"tick\", ticked);\n//                 simulation.force(\"link\")\n//                     .links(graph.links);\n//                 function ticked() {\n//                   link\n//                       .attr(\"x1\", function(d) { return d.source.x; })\n//                       .attr(\"y1\", function(d) { return d.source.y; })\n//                       .attr(\"x2\", function(d) { return d.target.x; })\n//                       .attr(\"y2\", function(d) { return d.target.y; });\n//                   node\n//                        .attr(\"r\", 16)\n//                        .style(\"fill\", \"#efefef\")\n//                        .style(\"stroke\", \"#424242\")\n//                        .style(\"stroke-width\", \"1px\")\n//                        .attr(\"cx\", function (d) { return d.x+5; })\n//                        .attr(\"cy\", function(d) { return d.y-3; });\n//                 }\n//               }\n//\n//\n//               run(graph)\n//\n//\n// });\n\n\nconst draw = require(\"./test3.js\");\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  draw();\n});\n","const draw3 = function(){\n  let width = 900,\n      height = 900;\n\n  let matrix = [\n    [0,4,4,4,0,0,0,0,0,0],\n    [0,0,0,0,25,25,25,0,0,0],\n    [0,0,0,0,0,25,25,25,0,0],\n    [0,0,0,0,0,0,25,25,25,0],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,1],\n    [0,0,0,0,0,0,0,0,0,0]\n\n  ]\n\n  let nodes = [\n    {label: \"s\", index: 0, profit: null, row: null, fixed: true, x: width/2, y: height-100},\n    {label: \"1\", index: 1, profit:4, row: 1, fixed: true, x: width/2-150, y: height - 325},\n    {label: \"2\", index: 2, profit: 4, row: 1},\n    {label: \"3\", index: 3, profit: 4, row: 1, fixed: true, x: width/2+150, y: height - 325},\n    {label: \"4\", index: 4, profit: -1, row: 0, fixed: true, x: width/2 - 200, y: 325},\n    {label: \"5\", index: 5, profit: -1, row: 0},\n    {label: \"6\", index: 6, profit: -1, row: 0},\n    {label: \"7\", index: 7, profit: -1, row: 0},\n    {label: \"8\", index: 8, profit: -1, row: 0, fixed: true, x: width/2 + 200, y: 325},\n    {label: \"t\", index: 9, profit: null, row: null, fixed: true, x: width/2, y: 100}\n  ]\n\n  let links = [\n  ]\n\n  //defines the u -> v edges, i.e. must complete project v before starting project u\n  let restrictions = [\n    {source: 1, target: 4},\n    {source: 1, target: 5},\n    {source: 1, target: 6},\n    {source: 2, target: 5},\n    {source: 2, target: 6},\n    {source: 2, target: 7},\n    {source: 3, target: 6},\n    {source: 3, target: 7},\n    {source: 3, target: 8},\n  ]\n\n  //effectively the sum of all other capacities + 1 (commonly C + 1)\n  infCapacity = 0;\n\n  //computes C + 1\n  const simulateInfCapacity = () => {\n    nodes.forEach(node => {\n      if (node.profit !== null){\n        if (node.profit > 0){\n          infCapacity = infCapacity + node.profit\n        }else{\n          infCapacity = infCapacity - node.profit\n        }\n      }\n    })\n    infCapacity = infCapacity + 1;\n  }\n\n  //creates links with finite capacities\n  const setFiniteLinks = () => {\n    nodes.forEach((node,i) => {\n      // debugger\n      if (node.label !== \"s\" && node.label !== \"t\"){\n        if (node.profit > 0){\n          links.push({source: 0, target: i, capacity: node.profit})\n        }else{\n          links.push({source: i, target: (nodes.length-1), capacity: (-1 * node.profit), res: 0})\n        }\n      }\n    })\n  }\n  //creates links with infinite capacities\n  const setInfiniteLinks = () => {\n    restrictions.forEach(restriction => {\n      links.push({source: restriction.source, target: restriction.target, capacity: infCapacity})\n    })\n  }\n\n  simulateInfCapacity();\n  setInfiniteLinks();\n  setFiniteLinks();\n\n  //create object for manipulation\n  let svg = d3.select('body').append('svg')\n      .attr('width', width)\n      .attr('height', height);\n\n  //apply force conditions\n  let force = d3.layout.force()\n      .size([width, height])\n      .nodes(d3.values(nodes))\n      .links(links)\n      .on(\"tick\", tick)\n      // .linkDistance(100)\n      .gravity(0.1)\n      .charge(-1200)\n      .linkDistance(120)\n      .linkStrength(0.1)\n      .start();\n\n  //create links\n  let link = svg.selectAll('.link')\n      .data(links)\n      .enter().append('line')\n      .attr('class', 'link')\n      .style(\"stroke\", function(d){\n        if (d.capacity === infCapacity){\n          return \"#000\"\n        }else if (d.target.label === \"t\"){\n          return \"#632f12\"\n        }else if ( d.source.label === \"s\"){\n          return \"#fff\"\n        }\n      })\n      .style(\"stroke-width\", \"5\");\n\n  //create nodes\n  let node = svg.selectAll(\".node\")\n      .data(force.nodes())\n      .enter().append(\"g\")\n      .attr('class', 'node')\n      // .attr(\"transform\",transform);\n      .call(force.drag);\n\n  //add circle to visualize nodes\n  node.append(\"circle\")\n    .attr('r', 10)\n    .attr(\"fill\", function(d) {\n      if (d.label === \"s\"){\n        return \"#ce9308\"\n      }else if (d.label === \"t\"){\n        return \"#969696\"\n      }else if (d.profit !== null && d.profit > 0){\n        return \"#31703d\"\n      }else if (d.profit !== null && d.profit <= 0){\n         return \"#961919\"\n      }\n    })\n    .style(\"stroke\", \"#fff\")\n    .style(\"stroke-weight\", \"3\")\n\n  //add node labels\n  node.append(\"text\")\n  .attr(\"dx\", \"-.2em\")\n  .attr(\"dy\", \".35em\")\n  .style(\"fill\", \"white\")\n  .text(function(d) {return d.label})\n\n  link.append(\"linkText\")\n  .attr(\"dx\", \"-.2em\")\n  .attr(\"dy\", \".35em\")\n  .text(function(d) {return d.capacity})\n\n  svg.selectAll(\"circle\").filter(function(d) {\n    // debugger\n    return;\n  })\n  .attr(\"fill\", \"white\")\n  // .select(\"text\").text(\"X\")\n\n  function tick(e) {\n      node.attr('cx', function(d) {\n          return d.x;\n        })\n        .attr('cy', function(d) { return d.y; })\n        .attr(\"transform\", function(d) { return `translate(${d.x},${d.y})`; });\n\n      link.attr('x1', function(d) { return d.source.x; })\n          .attr('y1', function(d) { return d.source.y; })\n          .attr('x2', function(d) { return d.target.x; })\n          .attr('y2', function(d) { return d.target.y; });\n  }\n\n\n  // setTimeout(function(){\n  //   svg.selectAll(\"text\")\n  //   .filter(function(d){\n  //     return d.label === \"s\"\n  //   })\n  //   .text(\"5\");\n\n  // setTimeout(function(){\n  //   svg.selectAll(\".link\")\n  //   .filter(function(d){\n  //     debugger\n  //     return d.target.label === \"1\"\n  //   })\n  //   .transition()\n  //   .duration(1000)\n  //   .style(\"stroke\", \"red\")\n  // }, 1000);\n  //\n  // setTimeout(function(){\n  //   svg.selectAll(\".link\")\n  //   .filter(function(d){\n  //     debugger\n  //     return d.source.label === \"1\" && d.target.label===\"4\"\n  //   })\n  //   .transition()\n  //   .duration(1000)\n  //   .style(\"stroke\", \"red\")\n  // }, 2000);\n  //\n  // setTimeout(function(){\n  //   svg.selectAll(\".link\")\n  //   .filter(function(d){\n  //     debugger\n  //     return d.source.label === \"4\" && d.target.label===\"t\"\n  //   })\n  //   .transition()\n  //   .duration(1000)\n  //   .style(\"stroke\", \"red\")\n  // }, 3000);\n\n\n\n\n\n\n\n\n\n\n\n\n\n  const BFS = (graph, s, t, parent) => {\n    let visited = [];\n    for (let i = 0; i < 5; i++){\n      visited.push(false);\n    }\n\n    let queue = [];\n\n    queue.push(s);\n    visited[s] = true;\n    // debugger\n    while (queue.length > 0) {\n      let currentVtx = queue.shift();\n\n      graph[currentVtx].forEach((val, i) => {\n        if (!visited[i] && val > 0){\n          queue.push(i);\n          visited[i] = true;\n          parent[i] = currentVtx;\n        }\n      })\n    }\n    return {pathToSink: visited[t], parent}\n  }\n\n  let parent = [];\n\n  for (let i = 0; i < matrix.length; i++){\n    parent.push(-1);\n  }\n\n  const EK = (graph, source, sink) => {\n\n\n    let max_flow = 0;\n    // debugger\n    let count = 1;\n    while (BFS(graph, source, sink, parent).pathToSink) {\n      let path_flow = 91;\n      let s = sink;\n      let path = [s];\n      while (s != source){\n        path_flow = Math.min(path_flow, graph[parent[s]][s]);\n        s = parent[s];\n        path.unshift(s);\n      }\n      animateBFS(path, count);\n      max_flow = max_flow + path_flow;\n      // debugger\n      count = count + (path.length - 1);\n\n      let t = sink;\n\n      while (t != source){\n        let u = parent[t];\n        graph[u][t] =  graph[u][t] - path_flow;\n        graph[t][u] = graph[t][u] + path_flow;\n        t = parent[t];\n      }\n\n      resetBFSLinks(path, count);\n      count = count + 1;\n    }\n\n    let solution = [];\n    graph.forEach((arr,i) => {\n      if (arr[0] > 0){\n          solution.push(i)\n      }\n  })\n    return {max_flow, solution};\n  }\n\n\n  EK(matrix,0,9);\n  // debugger\n\n  function animateBFS(path, count) {\n    for (let i = 0; i < path.length - 1; i++){\n      setTimeout(function(){\n        svg.selectAll(\".link\")\n        .filter(function(d){\n          return d.source.index === path[i] && d.target.index === path[i+1]\n        })\n        .transition()\n        .duration(1000)\n        .style(\"stroke\", \"red\")\n      }, 1000*count)\n      count = count + 1\n      // debugger\n    }\n\n  }\n\n  function resetBFSLinks(path,count){\n    for (let i = 0; i < path.length - 1; i++){\n      setTimeout(function(){\n        svg.selectAll(\".link\")\n        .filter(function(d){\n          // debugger\n          return d.source.index === path[i] && d.target.index === path[i+1]\n        })\n        .transition()\n        .duration(1000)\n        .style(\"stroke\", function(d){\n          if (d.capacity === infCapacity){\n            return \"#000\"\n          }else if (d.target.label === \"t\"){\n            return \"#632f12\"\n          }else if ( d.source.label === \"s\"){\n            return \"#fff\"\n          }\n        })\n      }, 1000*count)\n    }\n  }\n}\n\n\nmodule.exports = draw3;\n"],"sourceRoot":""}